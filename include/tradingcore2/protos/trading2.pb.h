// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trading2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_trading2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_trading2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_trading2_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_trading2_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_trading2_2eproto;
namespace tradingpb {
class AIPParams;
class AIPParamsDefaultTypeInternal;
extern AIPParamsDefaultTypeInternal _AIPParams_default_instance_;
class Asset;
class AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class BasicRequestData;
class BasicRequestDataDefaultTypeInternal;
extern BasicRequestDataDefaultTypeInternal _BasicRequestData_default_instance_;
class BuyParams;
class BuyParamsDefaultTypeInternal;
extern BuyParamsDefaultTypeInternal _BuyParams_default_instance_;
class CtrlCondition;
class CtrlConditionDefaultTypeInternal;
extern CtrlConditionDefaultTypeInternal _CtrlCondition_default_instance_;
class CtrlNode;
class CtrlNodeDefaultTypeInternal;
extern CtrlNodeDefaultTypeInternal _CtrlNode_default_instance_;
class CtrlNodeAssetInfo;
class CtrlNodeAssetInfoDefaultTypeInternal;
extern CtrlNodeAssetInfoDefaultTypeInternal _CtrlNodeAssetInfo_default_instance_;
class CtrlNode_MapAssetsInfoEntry_DoNotUse;
class CtrlNode_MapAssetsInfoEntry_DoNotUseDefaultTypeInternal;
extern CtrlNode_MapAssetsInfoEntry_DoNotUseDefaultTypeInternal _CtrlNode_MapAssetsInfoEntry_DoNotUse_default_instance_;
class FeeParams;
class FeeParamsDefaultTypeInternal;
extern FeeParamsDefaultTypeInternal _FeeParams_default_instance_;
class Indicator;
class IndicatorDefaultTypeInternal;
extern IndicatorDefaultTypeInternal _Indicator_default_instance_;
class IndicatorData;
class IndicatorDataDefaultTypeInternal;
extern IndicatorDataDefaultTypeInternal _IndicatorData_default_instance_;
class InitParams;
class InitParamsDefaultTypeInternal;
extern InitParamsDefaultTypeInternal _InitParams_default_instance_;
class PNLAssetData;
class PNLAssetDataDefaultTypeInternal;
extern PNLAssetDataDefaultTypeInternal _PNLAssetData_default_instance_;
class PNLData;
class PNLDataDefaultTypeInternal;
extern PNLDataDefaultTypeInternal _PNLData_default_instance_;
class PNLDataValue;
class PNLDataValueDefaultTypeInternal;
extern PNLDataValueDefaultTypeInternal _PNLDataValue_default_instance_;
class SellParams;
class SellParamsDefaultTypeInternal;
extern SellParamsDefaultTypeInternal _SellParams_default_instance_;
class SimTradingCache;
class SimTradingCacheDefaultTypeInternal;
extern SimTradingCacheDefaultTypeInternal _SimTradingCache_default_instance_;
class SimTradingCacheNode;
class SimTradingCacheNodeDefaultTypeInternal;
extern SimTradingCacheNodeDefaultTypeInternal _SimTradingCacheNode_default_instance_;
class SimTradingParams;
class SimTradingParamsDefaultTypeInternal;
extern SimTradingParamsDefaultTypeInternal _SimTradingParams_default_instance_;
class StopLossParams;
class StopLossParamsDefaultTypeInternal;
extern StopLossParamsDefaultTypeInternal _StopLossParams_default_instance_;
class Strategy;
class StrategyDefaultTypeInternal;
extern StrategyDefaultTypeInternal _Strategy_default_instance_;
class TakeProfitParams;
class TakeProfitParamsDefaultTypeInternal;
extern TakeProfitParamsDefaultTypeInternal _TakeProfitParams_default_instance_;
class TradingNodeInfo;
class TradingNodeInfoDefaultTypeInternal;
extern TradingNodeInfoDefaultTypeInternal _TradingNodeInfo_default_instance_;
class Wallet;
class WalletDefaultTypeInternal;
extern WalletDefaultTypeInternal _Wallet_default_instance_;
class WalletAsset;
class WalletAssetDefaultTypeInternal;
extern WalletAssetDefaultTypeInternal _WalletAsset_default_instance_;
}  // namespace tradingpb
PROTOBUF_NAMESPACE_OPEN
template<> ::tradingpb::AIPParams* Arena::CreateMaybeMessage<::tradingpb::AIPParams>(Arena*);
template<> ::tradingpb::Asset* Arena::CreateMaybeMessage<::tradingpb::Asset>(Arena*);
template<> ::tradingpb::BasicRequestData* Arena::CreateMaybeMessage<::tradingpb::BasicRequestData>(Arena*);
template<> ::tradingpb::BuyParams* Arena::CreateMaybeMessage<::tradingpb::BuyParams>(Arena*);
template<> ::tradingpb::CtrlCondition* Arena::CreateMaybeMessage<::tradingpb::CtrlCondition>(Arena*);
template<> ::tradingpb::CtrlNode* Arena::CreateMaybeMessage<::tradingpb::CtrlNode>(Arena*);
template<> ::tradingpb::CtrlNodeAssetInfo* Arena::CreateMaybeMessage<::tradingpb::CtrlNodeAssetInfo>(Arena*);
template<> ::tradingpb::CtrlNode_MapAssetsInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::tradingpb::CtrlNode_MapAssetsInfoEntry_DoNotUse>(Arena*);
template<> ::tradingpb::FeeParams* Arena::CreateMaybeMessage<::tradingpb::FeeParams>(Arena*);
template<> ::tradingpb::Indicator* Arena::CreateMaybeMessage<::tradingpb::Indicator>(Arena*);
template<> ::tradingpb::IndicatorData* Arena::CreateMaybeMessage<::tradingpb::IndicatorData>(Arena*);
template<> ::tradingpb::InitParams* Arena::CreateMaybeMessage<::tradingpb::InitParams>(Arena*);
template<> ::tradingpb::PNLAssetData* Arena::CreateMaybeMessage<::tradingpb::PNLAssetData>(Arena*);
template<> ::tradingpb::PNLData* Arena::CreateMaybeMessage<::tradingpb::PNLData>(Arena*);
template<> ::tradingpb::PNLDataValue* Arena::CreateMaybeMessage<::tradingpb::PNLDataValue>(Arena*);
template<> ::tradingpb::SellParams* Arena::CreateMaybeMessage<::tradingpb::SellParams>(Arena*);
template<> ::tradingpb::SimTradingCache* Arena::CreateMaybeMessage<::tradingpb::SimTradingCache>(Arena*);
template<> ::tradingpb::SimTradingCacheNode* Arena::CreateMaybeMessage<::tradingpb::SimTradingCacheNode>(Arena*);
template<> ::tradingpb::SimTradingParams* Arena::CreateMaybeMessage<::tradingpb::SimTradingParams>(Arena*);
template<> ::tradingpb::StopLossParams* Arena::CreateMaybeMessage<::tradingpb::StopLossParams>(Arena*);
template<> ::tradingpb::Strategy* Arena::CreateMaybeMessage<::tradingpb::Strategy>(Arena*);
template<> ::tradingpb::TakeProfitParams* Arena::CreateMaybeMessage<::tradingpb::TakeProfitParams>(Arena*);
template<> ::tradingpb::TradingNodeInfo* Arena::CreateMaybeMessage<::tradingpb::TradingNodeInfo>(Arena*);
template<> ::tradingpb::Wallet* Arena::CreateMaybeMessage<::tradingpb::Wallet>(Arena*);
template<> ::tradingpb::WalletAsset* Arena::CreateMaybeMessage<::tradingpb::WalletAsset>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tradingpb {

enum CtrlType : int {
  CTRL_INIT = 0,
  CTRL_BUY = 1,
  CTRL_SELL = 2,
  CTRL_STOPLOSS = 3,
  CTRL_TAKEPROFIT = 4,
  CTRL_WITHDRAW = 5,
  CTRL_DEPOSIT = 6,
  CtrlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CtrlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CtrlType_IsValid(int value);
constexpr CtrlType CtrlType_MIN = CTRL_INIT;
constexpr CtrlType CtrlType_MAX = CTRL_DEPOSIT;
constexpr int CtrlType_ARRAYSIZE = CtrlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CtrlType_descriptor();
template<typename T>
inline const std::string& CtrlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CtrlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CtrlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CtrlType_descriptor(), enum_t_value);
}
inline bool CtrlType_Parse(
    const std::string& name, CtrlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CtrlType>(
    CtrlType_descriptor(), name, value);
}
enum IndicatorType : int {
  IT_SINGLEVALUE = 0,
  IT_SINGLEPRICE = 1,
  IndicatorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  IndicatorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool IndicatorType_IsValid(int value);
constexpr IndicatorType IndicatorType_MIN = IT_SINGLEVALUE;
constexpr IndicatorType IndicatorType_MAX = IT_SINGLEPRICE;
constexpr int IndicatorType_ARRAYSIZE = IndicatorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndicatorType_descriptor();
template<typename T>
inline const std::string& IndicatorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndicatorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndicatorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndicatorType_descriptor(), enum_t_value);
}
inline bool IndicatorType_Parse(
    const std::string& name, IndicatorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndicatorType>(
    IndicatorType_descriptor(), name, value);
}
enum AIPTimeType : int {
  AIPTT_WEEKDAY = 0,
  AIPTT_MONTHDAY = 1,
  AIPTimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AIPTimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AIPTimeType_IsValid(int value);
constexpr AIPTimeType AIPTimeType_MIN = AIPTT_WEEKDAY;
constexpr AIPTimeType AIPTimeType_MAX = AIPTT_MONTHDAY;
constexpr int AIPTimeType_ARRAYSIZE = AIPTimeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AIPTimeType_descriptor();
template<typename T>
inline const std::string& AIPTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AIPTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AIPTimeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AIPTimeType_descriptor(), enum_t_value);
}
inline bool AIPTimeType_Parse(
    const std::string& name, AIPTimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AIPTimeType>(
    AIPTimeType_descriptor(), name, value);
}
// ===================================================================

class BasicRequestData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.BasicRequestData) */ {
 public:
  BasicRequestData();
  virtual ~BasicRequestData();

  BasicRequestData(const BasicRequestData& from);
  BasicRequestData(BasicRequestData&& from) noexcept
    : BasicRequestData() {
    *this = ::std::move(from);
  }

  inline BasicRequestData& operator=(const BasicRequestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicRequestData& operator=(BasicRequestData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BasicRequestData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasicRequestData* internal_default_instance() {
    return reinterpret_cast<const BasicRequestData*>(
               &_BasicRequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BasicRequestData& a, BasicRequestData& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicRequestData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BasicRequestData* New() const final {
    return CreateMaybeMessage<BasicRequestData>(nullptr);
  }

  BasicRequestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BasicRequestData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BasicRequestData& from);
  void MergeFrom(const BasicRequestData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicRequestData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.BasicRequestData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.BasicRequestData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class Asset :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);
  Asset(Asset&& from) noexcept
    : Asset() {
    *this = ::std::move(from);
  }

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset& operator=(Asset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Asset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Asset& a, Asset& b) {
    a.Swap(&b);
  }
  inline void Swap(Asset* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Asset* New() const final {
    return CreateMaybeMessage<Asset>(nullptr);
  }

  Asset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Asset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Asset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.Asset";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kMarketFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string market = 1;
  void clear_market();
  const std::string& market() const;
  void set_market(const std::string& value);
  void set_market(std::string&& value);
  void set_market(const char* value);
  void set_market(const char* value, size_t size);
  std::string* mutable_market();
  std::string* release_market();
  void set_allocated_market(std::string* market);
  private:
  const std::string& _internal_market() const;
  void _internal_set_market(const std::string& value);
  std::string* _internal_mutable_market();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.Asset)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class CtrlNodeAssetInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.CtrlNodeAssetInfo) */ {
 public:
  CtrlNodeAssetInfo();
  virtual ~CtrlNodeAssetInfo();

  CtrlNodeAssetInfo(const CtrlNodeAssetInfo& from);
  CtrlNodeAssetInfo(CtrlNodeAssetInfo&& from) noexcept
    : CtrlNodeAssetInfo() {
    *this = ::std::move(from);
  }

  inline CtrlNodeAssetInfo& operator=(const CtrlNodeAssetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CtrlNodeAssetInfo& operator=(CtrlNodeAssetInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CtrlNodeAssetInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtrlNodeAssetInfo* internal_default_instance() {
    return reinterpret_cast<const CtrlNodeAssetInfo*>(
               &_CtrlNodeAssetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CtrlNodeAssetInfo& a, CtrlNodeAssetInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CtrlNodeAssetInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CtrlNodeAssetInfo* New() const final {
    return CreateMaybeMessage<CtrlNodeAssetInfo>(nullptr);
  }

  CtrlNodeAssetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CtrlNodeAssetInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CtrlNodeAssetInfo& from);
  void MergeFrom(const CtrlNodeAssetInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtrlNodeAssetInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.CtrlNodeAssetInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // double volume = 1;
  void clear_volume();
  double volume() const;
  void set_volume(double value);
  private:
  double _internal_volume() const;
  void _internal_set_volume(double value);
  public:

  // double cost = 2;
  void clear_cost();
  double cost() const;
  void set_cost(double value);
  private:
  double _internal_cost() const;
  void _internal_set_cost(double value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.CtrlNodeAssetInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double volume_;
  double cost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class CtrlNode_MapAssetsInfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CtrlNode_MapAssetsInfoEntry_DoNotUse, 
    std::string, ::tradingpb::CtrlNodeAssetInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CtrlNode_MapAssetsInfoEntry_DoNotUse, 
    std::string, ::tradingpb::CtrlNodeAssetInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  CtrlNode_MapAssetsInfoEntry_DoNotUse();
  CtrlNode_MapAssetsInfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CtrlNode_MapAssetsInfoEntry_DoNotUse& other);
  static const CtrlNode_MapAssetsInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CtrlNode_MapAssetsInfoEntry_DoNotUse*>(&_CtrlNode_MapAssetsInfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tradingpb.CtrlNode.MapAssetsInfoEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class CtrlNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.CtrlNode) */ {
 public:
  CtrlNode();
  virtual ~CtrlNode();

  CtrlNode(const CtrlNode& from);
  CtrlNode(CtrlNode&& from) noexcept
    : CtrlNode() {
    *this = ::std::move(from);
  }

  inline CtrlNode& operator=(const CtrlNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CtrlNode& operator=(CtrlNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CtrlNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtrlNode* internal_default_instance() {
    return reinterpret_cast<const CtrlNode*>(
               &_CtrlNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CtrlNode& a, CtrlNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CtrlNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CtrlNode* New() const final {
    return CreateMaybeMessage<CtrlNode>(nullptr);
  }

  CtrlNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CtrlNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CtrlNode& from);
  void MergeFrom(const CtrlNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtrlNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.CtrlNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMapAssetsInfoFieldNumber = 14,
    kSrcFieldNumber = 2,
    kDstFieldNumber = 3,
    kTsFieldNumber = 1,
    kVolumeSrcFieldNumber = 4,
    kVolumeDstFieldNumber = 5,
    kFeeFieldNumber = 7,
    kAverageHoldingPriceFieldNumber = 8,
    kTypeFieldNumber = 6,
    kCtrlConditionIDFieldNumber = 10,
    kSellPriceFieldNumber = 9,
    kTotalMoneyFieldNumber = 12,
    kLastMoneyFieldNumber = 13,
    kStrategyIDFieldNumber = 11,
    kMoneyPartsFieldNumber = 15,
    kLastMoneyPartsFieldNumber = 16,
  };
  // map<string, .tradingpb.CtrlNodeAssetInfo> mapAssetsInfo = 14;
  int mapassetsinfo_size() const;
  private:
  int _internal_mapassetsinfo_size() const;
  public:
  void clear_mapassetsinfo();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >&
      _internal_mapassetsinfo() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >*
      _internal_mutable_mapassetsinfo();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >&
      mapassetsinfo() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >*
      mutable_mapassetsinfo();

  // .tradingpb.Asset src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::tradingpb::Asset& src() const;
  ::tradingpb::Asset* release_src();
  ::tradingpb::Asset* mutable_src();
  void set_allocated_src(::tradingpb::Asset* src);
  private:
  const ::tradingpb::Asset& _internal_src() const;
  ::tradingpb::Asset* _internal_mutable_src();
  public:

  // .tradingpb.Asset dst = 3;
  bool has_dst() const;
  private:
  bool _internal_has_dst() const;
  public:
  void clear_dst();
  const ::tradingpb::Asset& dst() const;
  ::tradingpb::Asset* release_dst();
  ::tradingpb::Asset* mutable_dst();
  void set_allocated_dst(::tradingpb::Asset* dst);
  private:
  const ::tradingpb::Asset& _internal_dst() const;
  ::tradingpb::Asset* _internal_mutable_dst();
  public:

  // int64 ts = 1;
  void clear_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 ts() const;
  void set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ts() const;
  void _internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double volumeSrc = 4;
  void clear_volumesrc();
  double volumesrc() const;
  void set_volumesrc(double value);
  private:
  double _internal_volumesrc() const;
  void _internal_set_volumesrc(double value);
  public:

  // double volumeDst = 5;
  void clear_volumedst();
  double volumedst() const;
  void set_volumedst(double value);
  private:
  double _internal_volumedst() const;
  void _internal_set_volumedst(double value);
  public:

  // double fee = 7;
  void clear_fee();
  double fee() const;
  void set_fee(double value);
  private:
  double _internal_fee() const;
  void _internal_set_fee(double value);
  public:

  // double averageHoldingPrice = 8;
  void clear_averageholdingprice();
  double averageholdingprice() const;
  void set_averageholdingprice(double value);
  private:
  double _internal_averageholdingprice() const;
  void _internal_set_averageholdingprice(double value);
  public:

  // .tradingpb.CtrlType type = 6;
  void clear_type();
  ::tradingpb::CtrlType type() const;
  void set_type(::tradingpb::CtrlType value);
  private:
  ::tradingpb::CtrlType _internal_type() const;
  void _internal_set_type(::tradingpb::CtrlType value);
  public:

  // int32 ctrlConditionID = 10;
  void clear_ctrlconditionid();
  ::PROTOBUF_NAMESPACE_ID::int32 ctrlconditionid() const;
  void set_ctrlconditionid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ctrlconditionid() const;
  void _internal_set_ctrlconditionid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double sellPrice = 9;
  void clear_sellprice();
  double sellprice() const;
  void set_sellprice(double value);
  private:
  double _internal_sellprice() const;
  void _internal_set_sellprice(double value);
  public:

  // double totalMoney = 12;
  void clear_totalmoney();
  double totalmoney() const;
  void set_totalmoney(double value);
  private:
  double _internal_totalmoney() const;
  void _internal_set_totalmoney(double value);
  public:

  // double lastMoney = 13;
  void clear_lastmoney();
  double lastmoney() const;
  void set_lastmoney(double value);
  private:
  double _internal_lastmoney() const;
  void _internal_set_lastmoney(double value);
  public:

  // int32 strategyID = 11;
  void clear_strategyid();
  ::PROTOBUF_NAMESPACE_ID::int32 strategyid() const;
  void set_strategyid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_strategyid() const;
  void _internal_set_strategyid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 moneyParts = 15;
  void clear_moneyparts();
  ::PROTOBUF_NAMESPACE_ID::int32 moneyparts() const;
  void set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_moneyparts() const;
  void _internal_set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lastMoneyParts = 16;
  void clear_lastmoneyparts();
  ::PROTOBUF_NAMESPACE_ID::int32 lastmoneyparts() const;
  void set_lastmoneyparts(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lastmoneyparts() const;
  void _internal_set_lastmoneyparts(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.CtrlNode)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CtrlNode_MapAssetsInfoEntry_DoNotUse,
      std::string, ::tradingpb::CtrlNodeAssetInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > mapassetsinfo_;
  ::tradingpb::Asset* src_;
  ::tradingpb::Asset* dst_;
  ::PROTOBUF_NAMESPACE_ID::int64 ts_;
  double volumesrc_;
  double volumedst_;
  double fee_;
  double averageholdingprice_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 ctrlconditionid_;
  double sellprice_;
  double totalmoney_;
  double lastmoney_;
  ::PROTOBUF_NAMESPACE_ID::int32 strategyid_;
  ::PROTOBUF_NAMESPACE_ID::int32 moneyparts_;
  ::PROTOBUF_NAMESPACE_ID::int32 lastmoneyparts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class WalletAsset :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.WalletAsset) */ {
 public:
  WalletAsset();
  virtual ~WalletAsset();

  WalletAsset(const WalletAsset& from);
  WalletAsset(WalletAsset&& from) noexcept
    : WalletAsset() {
    *this = ::std::move(from);
  }

  inline WalletAsset& operator=(const WalletAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletAsset& operator=(WalletAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WalletAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WalletAsset* internal_default_instance() {
    return reinterpret_cast<const WalletAsset*>(
               &_WalletAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WalletAsset& a, WalletAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletAsset* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WalletAsset* New() const final {
    return CreateMaybeMessage<WalletAsset>(nullptr);
  }

  WalletAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WalletAsset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WalletAsset& from);
  void MergeFrom(const WalletAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletAsset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.WalletAsset";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .tradingpb.Asset asset = 1;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::tradingpb::Asset& asset() const;
  ::tradingpb::Asset* release_asset();
  ::tradingpb::Asset* mutable_asset();
  void set_allocated_asset(::tradingpb::Asset* asset);
  private:
  const ::tradingpb::Asset& _internal_asset() const;
  ::tradingpb::Asset* _internal_mutable_asset();
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.WalletAsset)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tradingpb::Asset* asset_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class Wallet :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.Wallet) */ {
 public:
  Wallet();
  virtual ~Wallet();

  Wallet(const Wallet& from);
  Wallet(Wallet&& from) noexcept
    : Wallet() {
    *this = ::std::move(from);
  }

  inline Wallet& operator=(const Wallet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wallet& operator=(Wallet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wallet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wallet* internal_default_instance() {
    return reinterpret_cast<const Wallet*>(
               &_Wallet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Wallet& a, Wallet& b) {
    a.Swap(&b);
  }
  inline void Swap(Wallet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wallet* New() const final {
    return CreateMaybeMessage<Wallet>(nullptr);
  }

  Wallet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wallet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wallet& from);
  void MergeFrom(const Wallet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wallet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.Wallet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetsFieldNumber = 1,
  };
  // repeated .tradingpb.WalletAsset assets = 1;
  int assets_size() const;
  private:
  int _internal_assets_size() const;
  public:
  void clear_assets();
  ::tradingpb::WalletAsset* mutable_assets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::WalletAsset >*
      mutable_assets();
  private:
  const ::tradingpb::WalletAsset& _internal_assets(int index) const;
  ::tradingpb::WalletAsset* _internal_add_assets();
  public:
  const ::tradingpb::WalletAsset& assets(int index) const;
  ::tradingpb::WalletAsset* add_assets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::WalletAsset >&
      assets() const;

  // @@protoc_insertion_point(class_scope:tradingpb.Wallet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::WalletAsset > assets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class CtrlCondition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.CtrlCondition) */ {
 public:
  CtrlCondition();
  virtual ~CtrlCondition();

  CtrlCondition(const CtrlCondition& from);
  CtrlCondition(CtrlCondition&& from) noexcept
    : CtrlCondition() {
    *this = ::std::move(from);
  }

  inline CtrlCondition& operator=(const CtrlCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CtrlCondition& operator=(CtrlCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CtrlCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtrlCondition* internal_default_instance() {
    return reinterpret_cast<const CtrlCondition*>(
               &_CtrlCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CtrlCondition& a, CtrlCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CtrlCondition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CtrlCondition* New() const final {
    return CreateMaybeMessage<CtrlCondition>(nullptr);
  }

  CtrlCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CtrlCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CtrlCondition& from);
  void MergeFrom(const CtrlCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtrlCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.CtrlCondition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 2,
    kOperatorsFieldNumber = 3,
    kMinvalsFieldNumber = 5,
    kMaxvalsFieldNumber = 6,
    kOffvalsFieldNumber = 7,
    kStrValsFieldNumber = 8,
    kInt64ValsFieldNumber = 11,
    kIndicatorFieldNumber = 1,
    kCombConditionFieldNumber = 4,
    kNameFieldNumber = 9,
    kGroupFieldNumber = 10,
  };
  // repeated float vals = 2;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  float _internal_vals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vals() const;
  void _internal_add_vals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vals();
  public:
  float vals(int index) const;
  void set_vals(int index, float value);
  void add_vals(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vals();

  // repeated string operators = 3;
  int operators_size() const;
  private:
  int _internal_operators_size() const;
  public:
  void clear_operators();
  const std::string& operators(int index) const;
  std::string* mutable_operators(int index);
  void set_operators(int index, const std::string& value);
  void set_operators(int index, std::string&& value);
  void set_operators(int index, const char* value);
  void set_operators(int index, const char* value, size_t size);
  std::string* add_operators();
  void add_operators(const std::string& value);
  void add_operators(std::string&& value);
  void add_operators(const char* value);
  void add_operators(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& operators() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_operators();
  private:
  const std::string& _internal_operators(int index) const;
  std::string* _internal_add_operators();
  public:

  // repeated float minvals = 5 [deprecated = true];
  PROTOBUF_DEPRECATED int minvals_size() const;
  private:
  int _internal_minvals_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_minvals();
  private:
  float _internal_minvals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_minvals() const;
  void _internal_add_minvals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_minvals();
  public:
  PROTOBUF_DEPRECATED float minvals(int index) const;
  PROTOBUF_DEPRECATED void set_minvals(int index, float value);
  PROTOBUF_DEPRECATED void add_minvals(float value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      minvals() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_minvals();

  // repeated float maxvals = 6 [deprecated = true];
  PROTOBUF_DEPRECATED int maxvals_size() const;
  private:
  int _internal_maxvals_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_maxvals();
  private:
  float _internal_maxvals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_maxvals() const;
  void _internal_add_maxvals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_maxvals();
  public:
  PROTOBUF_DEPRECATED float maxvals(int index) const;
  PROTOBUF_DEPRECATED void set_maxvals(int index, float value);
  PROTOBUF_DEPRECATED void add_maxvals(float value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      maxvals() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_maxvals();

  // repeated float offvals = 7 [deprecated = true];
  PROTOBUF_DEPRECATED int offvals_size() const;
  private:
  int _internal_offvals_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_offvals();
  private:
  float _internal_offvals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_offvals() const;
  void _internal_add_offvals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_offvals();
  public:
  PROTOBUF_DEPRECATED float offvals(int index) const;
  PROTOBUF_DEPRECATED void set_offvals(int index, float value);
  PROTOBUF_DEPRECATED void add_offvals(float value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      offvals() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_offvals();

  // repeated string strVals = 8;
  int strvals_size() const;
  private:
  int _internal_strvals_size() const;
  public:
  void clear_strvals();
  const std::string& strvals(int index) const;
  std::string* mutable_strvals(int index);
  void set_strvals(int index, const std::string& value);
  void set_strvals(int index, std::string&& value);
  void set_strvals(int index, const char* value);
  void set_strvals(int index, const char* value, size_t size);
  std::string* add_strvals();
  void add_strvals(const std::string& value);
  void add_strvals(std::string&& value);
  void add_strvals(const char* value);
  void add_strvals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& strvals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_strvals();
  private:
  const std::string& _internal_strvals(int index) const;
  std::string* _internal_add_strvals();
  public:

  // repeated float int64Vals = 11;
  int int64vals_size() const;
  private:
  int _internal_int64vals_size() const;
  public:
  void clear_int64vals();
  private:
  float _internal_int64vals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_int64vals() const;
  void _internal_add_int64vals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_int64vals();
  public:
  float int64vals(int index) const;
  void set_int64vals(int index, float value);
  void add_int64vals(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      int64vals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_int64vals();

  // string indicator = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_indicator();
  PROTOBUF_DEPRECATED const std::string& indicator() const;
  PROTOBUF_DEPRECATED void set_indicator(const std::string& value);
  PROTOBUF_DEPRECATED void set_indicator(std::string&& value);
  PROTOBUF_DEPRECATED void set_indicator(const char* value);
  PROTOBUF_DEPRECATED void set_indicator(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_indicator();
  PROTOBUF_DEPRECATED std::string* release_indicator();
  PROTOBUF_DEPRECATED void set_allocated_indicator(std::string* indicator);
  private:
  const std::string& _internal_indicator() const;
  void _internal_set_indicator(const std::string& value);
  std::string* _internal_mutable_indicator();
  public:

  // string combCondition = 4;
  void clear_combcondition();
  const std::string& combcondition() const;
  void set_combcondition(const std::string& value);
  void set_combcondition(std::string&& value);
  void set_combcondition(const char* value);
  void set_combcondition(const char* value, size_t size);
  std::string* mutable_combcondition();
  std::string* release_combcondition();
  void set_allocated_combcondition(std::string* combcondition);
  private:
  const std::string& _internal_combcondition() const;
  void _internal_set_combcondition(const std::string& value);
  std::string* _internal_mutable_combcondition();
  public:

  // string name = 9;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 group = 10;
  void clear_group();
  ::PROTOBUF_NAMESPACE_ID::int32 group() const;
  void set_group(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_group() const;
  void _internal_set_group(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.CtrlCondition)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vals_;
  mutable std::atomic<int> _vals_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> operators_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > minvals_;
  mutable std::atomic<int> _minvals_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > maxvals_;
  mutable std::atomic<int> _maxvals_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > offvals_;
  mutable std::atomic<int> _offvals_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> strvals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > int64vals_;
  mutable std::atomic<int> _int64vals_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indicator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr combcondition_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 group_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class IndicatorData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.IndicatorData) */ {
 public:
  IndicatorData();
  virtual ~IndicatorData();

  IndicatorData(const IndicatorData& from);
  IndicatorData(IndicatorData&& from) noexcept
    : IndicatorData() {
    *this = ::std::move(from);
  }

  inline IndicatorData& operator=(const IndicatorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndicatorData& operator=(IndicatorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndicatorData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndicatorData* internal_default_instance() {
    return reinterpret_cast<const IndicatorData*>(
               &_IndicatorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IndicatorData& a, IndicatorData& b) {
    a.Swap(&b);
  }
  inline void Swap(IndicatorData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndicatorData* New() const final {
    return CreateMaybeMessage<IndicatorData>(nullptr);
  }

  IndicatorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndicatorData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndicatorData& from);
  void MergeFrom(const IndicatorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndicatorData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.IndicatorData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 1,
    kTsFieldNumber = 2,
  };
  // repeated float vals = 1;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  float _internal_vals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vals() const;
  void _internal_add_vals(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vals();
  public:
  float vals(int index) const;
  void set_vals(int index, float value);
  void add_vals(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vals();

  // int64 ts = 2;
  void clear_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 ts() const;
  void set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ts() const;
  void _internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.IndicatorData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vals_;
  mutable std::atomic<int> _vals_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 ts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class Indicator :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.Indicator) */ {
 public:
  Indicator();
  virtual ~Indicator();

  Indicator(const Indicator& from);
  Indicator(Indicator&& from) noexcept
    : Indicator() {
    *this = ::std::move(from);
  }

  inline Indicator& operator=(const Indicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Indicator& operator=(Indicator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Indicator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Indicator* internal_default_instance() {
    return reinterpret_cast<const Indicator*>(
               &_Indicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Indicator& a, Indicator& b) {
    a.Swap(&b);
  }
  inline void Swap(Indicator* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Indicator* New() const final {
    return CreateMaybeMessage<Indicator>(nullptr);
  }

  Indicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Indicator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Indicator& from);
  void MergeFrom(const Indicator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Indicator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.Indicator";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kFullnameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .tradingpb.IndicatorData data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::tradingpb::IndicatorData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::IndicatorData >*
      mutable_data();
  private:
  const ::tradingpb::IndicatorData& _internal_data(int index) const;
  ::tradingpb::IndicatorData* _internal_add_data();
  public:
  const ::tradingpb::IndicatorData& data(int index) const;
  ::tradingpb::IndicatorData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::IndicatorData >&
      data() const;

  // string fullname = 1;
  void clear_fullname();
  const std::string& fullname() const;
  void set_fullname(const std::string& value);
  void set_fullname(std::string&& value);
  void set_fullname(const char* value);
  void set_fullname(const char* value, size_t size);
  std::string* mutable_fullname();
  std::string* release_fullname();
  void set_allocated_fullname(std::string* fullname);
  private:
  const std::string& _internal_fullname() const;
  void _internal_set_fullname(const std::string& value);
  std::string* _internal_mutable_fullname();
  public:

  // .tradingpb.IndicatorType type = 2;
  void clear_type();
  ::tradingpb::IndicatorType type() const;
  void set_type(::tradingpb::IndicatorType value);
  private:
  ::tradingpb::IndicatorType _internal_type() const;
  void _internal_set_type(::tradingpb::IndicatorType value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.Indicator)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::IndicatorData > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullname_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class BuyParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.BuyParams) */ {
 public:
  BuyParams();
  virtual ~BuyParams();

  BuyParams(const BuyParams& from);
  BuyParams(BuyParams&& from) noexcept
    : BuyParams() {
    *this = ::std::move(from);
  }

  inline BuyParams& operator=(const BuyParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyParams& operator=(BuyParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuyParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyParams* internal_default_instance() {
    return reinterpret_cast<const BuyParams*>(
               &_BuyParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BuyParams& a, BuyParams& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuyParams* New() const final {
    return CreateMaybeMessage<BuyParams>(nullptr);
  }

  BuyParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuyParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuyParams& from);
  void MergeFrom(const BuyParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.BuyParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetCodeFieldNumber = 8,
    kTimeTypeBuyAssetFieldNumber = 9,
    kTypeBuyAssetFieldNumber = 11,
    kInitMoneyFieldNumber = 1,
    kPerMoneyFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kAipMoneyFieldNumber = 4,
    kPerInitMoneyFieldNumber = 5,
    kPerHandMoneyFieldNumber = 6,
    kPerTotalMoneyFieldNumber = 7,
    kMoneyPartsFieldNumber = 12,
    kTsOffBuyFieldNumber = 10,
    kNextTimesFieldNumber = 13,
    kDepositMoneyFieldNumber = 14,
  };
  // string assetCode = 8;
  void clear_assetcode();
  const std::string& assetcode() const;
  void set_assetcode(const std::string& value);
  void set_assetcode(std::string&& value);
  void set_assetcode(const char* value);
  void set_assetcode(const char* value, size_t size);
  std::string* mutable_assetcode();
  std::string* release_assetcode();
  void set_allocated_assetcode(std::string* assetcode);
  private:
  const std::string& _internal_assetcode() const;
  void _internal_set_assetcode(const std::string& value);
  std::string* _internal_mutable_assetcode();
  public:

  // string timeTypeBuyAsset = 9;
  void clear_timetypebuyasset();
  const std::string& timetypebuyasset() const;
  void set_timetypebuyasset(const std::string& value);
  void set_timetypebuyasset(std::string&& value);
  void set_timetypebuyasset(const char* value);
  void set_timetypebuyasset(const char* value, size_t size);
  std::string* mutable_timetypebuyasset();
  std::string* release_timetypebuyasset();
  void set_allocated_timetypebuyasset(std::string* timetypebuyasset);
  private:
  const std::string& _internal_timetypebuyasset() const;
  void _internal_set_timetypebuyasset(const std::string& value);
  std::string* _internal_mutable_timetypebuyasset();
  public:

  // string typeBuyAsset = 11;
  void clear_typebuyasset();
  const std::string& typebuyasset() const;
  void set_typebuyasset(const std::string& value);
  void set_typebuyasset(std::string&& value);
  void set_typebuyasset(const char* value);
  void set_typebuyasset(const char* value, size_t size);
  std::string* mutable_typebuyasset();
  std::string* release_typebuyasset();
  void set_allocated_typebuyasset(std::string* typebuyasset);
  private:
  const std::string& _internal_typebuyasset() const;
  void _internal_set_typebuyasset(const std::string& value);
  std::string* _internal_mutable_typebuyasset();
  public:

  // float initMoney = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_initmoney();
  PROTOBUF_DEPRECATED float initmoney() const;
  PROTOBUF_DEPRECATED void set_initmoney(float value);
  private:
  float _internal_initmoney() const;
  void _internal_set_initmoney(float value);
  public:

  // float perMoney = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_permoney();
  PROTOBUF_DEPRECATED float permoney() const;
  PROTOBUF_DEPRECATED void set_permoney(float value);
  private:
  float _internal_permoney() const;
  void _internal_set_permoney(float value);
  public:

  // float volume = 3;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float aipMoney = 4;
  void clear_aipmoney();
  float aipmoney() const;
  void set_aipmoney(float value);
  private:
  float _internal_aipmoney() const;
  void _internal_set_aipmoney(float value);
  public:

  // float perInitMoney = 5;
  void clear_perinitmoney();
  float perinitmoney() const;
  void set_perinitmoney(float value);
  private:
  float _internal_perinitmoney() const;
  void _internal_set_perinitmoney(float value);
  public:

  // float perHandMoney = 6;
  void clear_perhandmoney();
  float perhandmoney() const;
  void set_perhandmoney(float value);
  private:
  float _internal_perhandmoney() const;
  void _internal_set_perhandmoney(float value);
  public:

  // float perTotalMoney = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_pertotalmoney();
  PROTOBUF_DEPRECATED float pertotalmoney() const;
  PROTOBUF_DEPRECATED void set_pertotalmoney(float value);
  private:
  float _internal_pertotalmoney() const;
  void _internal_set_pertotalmoney(float value);
  public:

  // int32 moneyParts = 12;
  void clear_moneyparts();
  ::PROTOBUF_NAMESPACE_ID::int32 moneyparts() const;
  void set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_moneyparts() const;
  void _internal_set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 tsOffBuy = 10;
  void clear_tsoffbuy();
  ::PROTOBUF_NAMESPACE_ID::int64 tsoffbuy() const;
  void set_tsoffbuy(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tsoffbuy() const;
  void _internal_set_tsoffbuy(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 nextTimes = 13;
  void clear_nexttimes();
  ::PROTOBUF_NAMESPACE_ID::int32 nexttimes() const;
  void set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nexttimes() const;
  void _internal_set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 depositMoney = 14;
  void clear_depositmoney();
  ::PROTOBUF_NAMESPACE_ID::int32 depositmoney() const;
  void set_depositmoney(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depositmoney() const;
  void _internal_set_depositmoney(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.BuyParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetcode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timetypebuyasset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr typebuyasset_;
  float initmoney_;
  float permoney_;
  float volume_;
  float aipmoney_;
  float perinitmoney_;
  float perhandmoney_;
  float pertotalmoney_;
  ::PROTOBUF_NAMESPACE_ID::int32 moneyparts_;
  ::PROTOBUF_NAMESPACE_ID::int64 tsoffbuy_;
  ::PROTOBUF_NAMESPACE_ID::int32 nexttimes_;
  ::PROTOBUF_NAMESPACE_ID::int32 depositmoney_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class SellParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.SellParams) */ {
 public:
  SellParams();
  virtual ~SellParams();

  SellParams(const SellParams& from);
  SellParams(SellParams&& from) noexcept
    : SellParams() {
    *this = ::std::move(from);
  }

  inline SellParams& operator=(const SellParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellParams& operator=(SellParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SellParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SellParams* internal_default_instance() {
    return reinterpret_cast<const SellParams*>(
               &_SellParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SellParams& a, SellParams& b) {
    a.Swap(&b);
  }
  inline void Swap(SellParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SellParams* New() const final {
    return CreateMaybeMessage<SellParams>(nullptr);
  }

  SellParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SellParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SellParams& from);
  void MergeFrom(const SellParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.SellParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetCodeFieldNumber = 5,
    kTimeTypeSellAssetFieldNumber = 6,
    kTypeSellAssetFieldNumber = 8,
    kVolumeFieldNumber = 1,
    kPerVolumeFieldNumber = 2,
    kKeepTimeFieldNumber = 4,
    kMoneyFieldNumber = 3,
    kNextTimesFieldNumber = 9,
    kTsOffSellFieldNumber = 7,
  };
  // string assetCode = 5;
  void clear_assetcode();
  const std::string& assetcode() const;
  void set_assetcode(const std::string& value);
  void set_assetcode(std::string&& value);
  void set_assetcode(const char* value);
  void set_assetcode(const char* value, size_t size);
  std::string* mutable_assetcode();
  std::string* release_assetcode();
  void set_allocated_assetcode(std::string* assetcode);
  private:
  const std::string& _internal_assetcode() const;
  void _internal_set_assetcode(const std::string& value);
  std::string* _internal_mutable_assetcode();
  public:

  // string timeTypeSellAsset = 6;
  void clear_timetypesellasset();
  const std::string& timetypesellasset() const;
  void set_timetypesellasset(const std::string& value);
  void set_timetypesellasset(std::string&& value);
  void set_timetypesellasset(const char* value);
  void set_timetypesellasset(const char* value, size_t size);
  std::string* mutable_timetypesellasset();
  std::string* release_timetypesellasset();
  void set_allocated_timetypesellasset(std::string* timetypesellasset);
  private:
  const std::string& _internal_timetypesellasset() const;
  void _internal_set_timetypesellasset(const std::string& value);
  std::string* _internal_mutable_timetypesellasset();
  public:

  // string typeSellAsset = 8;
  void clear_typesellasset();
  const std::string& typesellasset() const;
  void set_typesellasset(const std::string& value);
  void set_typesellasset(std::string&& value);
  void set_typesellasset(const char* value);
  void set_typesellasset(const char* value, size_t size);
  std::string* mutable_typesellasset();
  std::string* release_typesellasset();
  void set_allocated_typesellasset(std::string* typesellasset);
  private:
  const std::string& _internal_typesellasset() const;
  void _internal_set_typesellasset(const std::string& value);
  std::string* _internal_mutable_typesellasset();
  public:

  // float volume = 1;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float perVolume = 2;
  void clear_pervolume();
  float pervolume() const;
  void set_pervolume(float value);
  private:
  float _internal_pervolume() const;
  void _internal_set_pervolume(float value);
  public:

  // int64 keepTime = 4;
  void clear_keeptime();
  ::PROTOBUF_NAMESPACE_ID::int64 keeptime() const;
  void set_keeptime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_keeptime() const;
  void _internal_set_keeptime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float money = 3;
  void clear_money();
  float money() const;
  void set_money(float value);
  private:
  float _internal_money() const;
  void _internal_set_money(float value);
  public:

  // int32 nextTimes = 9;
  void clear_nexttimes();
  ::PROTOBUF_NAMESPACE_ID::int32 nexttimes() const;
  void set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nexttimes() const;
  void _internal_set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 tsOffSell = 7;
  void clear_tsoffsell();
  ::PROTOBUF_NAMESPACE_ID::int64 tsoffsell() const;
  void set_tsoffsell(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tsoffsell() const;
  void _internal_set_tsoffsell(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.SellParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetcode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timetypesellasset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr typesellasset_;
  float volume_;
  float pervolume_;
  ::PROTOBUF_NAMESPACE_ID::int64 keeptime_;
  float money_;
  ::PROTOBUF_NAMESPACE_ID::int32 nexttimes_;
  ::PROTOBUF_NAMESPACE_ID::int64 tsoffsell_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class StopLossParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.StopLossParams) */ {
 public:
  StopLossParams();
  virtual ~StopLossParams();

  StopLossParams(const StopLossParams& from);
  StopLossParams(StopLossParams&& from) noexcept
    : StopLossParams() {
    *this = ::std::move(from);
  }

  inline StopLossParams& operator=(const StopLossParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopLossParams& operator=(StopLossParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopLossParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopLossParams* internal_default_instance() {
    return reinterpret_cast<const StopLossParams*>(
               &_StopLossParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StopLossParams& a, StopLossParams& b) {
    a.Swap(&b);
  }
  inline void Swap(StopLossParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopLossParams* New() const final {
    return CreateMaybeMessage<StopLossParams>(nullptr);
  }

  StopLossParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopLossParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopLossParams& from);
  void MergeFrom(const StopLossParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopLossParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.StopLossParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawdownFieldNumber = 1,
    kIsFinishFieldNumber = 2,
    kPerVolumeFieldNumber = 3,
  };
  // float drawdown = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_drawdown();
  PROTOBUF_DEPRECATED float drawdown() const;
  PROTOBUF_DEPRECATED void set_drawdown(float value);
  private:
  float _internal_drawdown() const;
  void _internal_set_drawdown(float value);
  public:

  // bool isFinish = 2;
  void clear_isfinish();
  bool isfinish() const;
  void set_isfinish(bool value);
  private:
  bool _internal_isfinish() const;
  void _internal_set_isfinish(bool value);
  public:

  // float perVolume = 3;
  void clear_pervolume();
  float pervolume() const;
  void set_pervolume(float value);
  private:
  float _internal_pervolume() const;
  void _internal_set_pervolume(float value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.StopLossParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float drawdown_;
  bool isfinish_;
  float pervolume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class TakeProfitParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.TakeProfitParams) */ {
 public:
  TakeProfitParams();
  virtual ~TakeProfitParams();

  TakeProfitParams(const TakeProfitParams& from);
  TakeProfitParams(TakeProfitParams&& from) noexcept
    : TakeProfitParams() {
    *this = ::std::move(from);
  }

  inline TakeProfitParams& operator=(const TakeProfitParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakeProfitParams& operator=(TakeProfitParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakeProfitParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakeProfitParams* internal_default_instance() {
    return reinterpret_cast<const TakeProfitParams*>(
               &_TakeProfitParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TakeProfitParams& a, TakeProfitParams& b) {
    a.Swap(&b);
  }
  inline void Swap(TakeProfitParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TakeProfitParams* New() const final {
    return CreateMaybeMessage<TakeProfitParams>(nullptr);
  }

  TakeProfitParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakeProfitParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakeProfitParams& from);
  void MergeFrom(const TakeProfitParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakeProfitParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.TakeProfitParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGiveToFieldNumber = 4,
    kProfitFieldNumber = 1,
    kPerVolumeFieldNumber = 3,
    kIsFinishFieldNumber = 2,
    kIsOnlyProfitFieldNumber = 5,
  };
  // string giveTo = 4;
  void clear_giveto();
  const std::string& giveto() const;
  void set_giveto(const std::string& value);
  void set_giveto(std::string&& value);
  void set_giveto(const char* value);
  void set_giveto(const char* value, size_t size);
  std::string* mutable_giveto();
  std::string* release_giveto();
  void set_allocated_giveto(std::string* giveto);
  private:
  const std::string& _internal_giveto() const;
  void _internal_set_giveto(const std::string& value);
  std::string* _internal_mutable_giveto();
  public:

  // float profit = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_profit();
  PROTOBUF_DEPRECATED float profit() const;
  PROTOBUF_DEPRECATED void set_profit(float value);
  private:
  float _internal_profit() const;
  void _internal_set_profit(float value);
  public:

  // float perVolume = 3;
  void clear_pervolume();
  float pervolume() const;
  void set_pervolume(float value);
  private:
  float _internal_pervolume() const;
  void _internal_set_pervolume(float value);
  public:

  // bool isFinish = 2;
  void clear_isfinish();
  bool isfinish() const;
  void set_isfinish(bool value);
  private:
  bool _internal_isfinish() const;
  void _internal_set_isfinish(bool value);
  public:

  // bool isOnlyProfit = 5;
  void clear_isonlyprofit();
  bool isonlyprofit() const;
  void set_isonlyprofit(bool value);
  private:
  bool _internal_isonlyprofit() const;
  void _internal_set_isonlyprofit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.TakeProfitParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr giveto_;
  float profit_;
  float pervolume_;
  bool isfinish_;
  bool isonlyprofit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class InitParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.InitParams) */ {
 public:
  InitParams();
  virtual ~InitParams();

  InitParams(const InitParams& from);
  InitParams(InitParams&& from) noexcept
    : InitParams() {
    *this = ::std::move(from);
  }

  inline InitParams& operator=(const InitParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitParams& operator=(InitParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitParams* internal_default_instance() {
    return reinterpret_cast<const InitParams*>(
               &_InitParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(InitParams& a, InitParams& b) {
    a.Swap(&b);
  }
  inline void Swap(InitParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitParams* New() const final {
    return CreateMaybeMessage<InitParams>(nullptr);
  }

  InitParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitParams& from);
  void MergeFrom(const InitParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.InitParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoneyFieldNumber = 1,
    kVomumeFieldNumber = 2,
  };
  // float money = 1;
  void clear_money();
  float money() const;
  void set_money(float value);
  private:
  float _internal_money() const;
  void _internal_set_money(float value);
  public:

  // float vomume = 2;
  void clear_vomume();
  float vomume() const;
  void set_vomume(float value);
  private:
  float _internal_vomume() const;
  void _internal_set_vomume(float value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.InitParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float money_;
  float vomume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class AIPParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.AIPParams) */ {
 public:
  AIPParams();
  virtual ~AIPParams();

  AIPParams(const AIPParams& from);
  AIPParams(AIPParams&& from) noexcept
    : AIPParams() {
    *this = ::std::move(from);
  }

  inline AIPParams& operator=(const AIPParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIPParams& operator=(AIPParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIPParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIPParams* internal_default_instance() {
    return reinterpret_cast<const AIPParams*>(
               &_AIPParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AIPParams& a, AIPParams& b) {
    a.Swap(&b);
  }
  inline void Swap(AIPParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AIPParams* New() const final {
    return CreateMaybeMessage<AIPParams>(nullptr);
  }

  AIPParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIPParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIPParams& from);
  void MergeFrom(const AIPParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIPParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.AIPParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoneyFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDayFieldNumber = 3,
  };
  // float money = 1;
  void clear_money();
  float money() const;
  void set_money(float value);
  private:
  float _internal_money() const;
  void _internal_set_money(float value);
  public:

  // .tradingpb.AIPTimeType type = 2;
  void clear_type();
  ::tradingpb::AIPTimeType type() const;
  void set_type(::tradingpb::AIPTimeType value);
  private:
  ::tradingpb::AIPTimeType _internal_type() const;
  void _internal_set_type(::tradingpb::AIPTimeType value);
  public:

  // int32 day = 3;
  void clear_day();
  ::PROTOBUF_NAMESPACE_ID::int32 day() const;
  void set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_day() const;
  void _internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.AIPParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float money_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 day_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class FeeParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.FeeParams) */ {
 public:
  FeeParams();
  virtual ~FeeParams();

  FeeParams(const FeeParams& from);
  FeeParams(FeeParams&& from) noexcept
    : FeeParams() {
    *this = ::std::move(from);
  }

  inline FeeParams& operator=(const FeeParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeParams& operator=(FeeParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeeParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeeParams* internal_default_instance() {
    return reinterpret_cast<const FeeParams*>(
               &_FeeParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FeeParams& a, FeeParams& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeeParams* New() const final {
    return CreateMaybeMessage<FeeParams>(nullptr);
  }

  FeeParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeeParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeeParams& from);
  void MergeFrom(const FeeParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.FeeParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentageFieldNumber = 1,
    kMinLimitFieldNumber = 2,
    kMaxLimitFieldNumber = 3,
  };
  // float percentage = 1;
  void clear_percentage();
  float percentage() const;
  void set_percentage(float value);
  private:
  float _internal_percentage() const;
  void _internal_set_percentage(float value);
  public:

  // float minLimit = 2;
  void clear_minlimit();
  float minlimit() const;
  void set_minlimit(float value);
  private:
  float _internal_minlimit() const;
  void _internal_set_minlimit(float value);
  public:

  // float maxLimit = 3;
  void clear_maxlimit();
  float maxlimit() const;
  void set_maxlimit(float value);
  private:
  float _internal_maxlimit() const;
  void _internal_set_maxlimit(float value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.FeeParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float percentage_;
  float minlimit_;
  float maxlimit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class Strategy :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.Strategy) */ {
 public:
  Strategy();
  virtual ~Strategy();

  Strategy(const Strategy& from);
  Strategy(Strategy&& from) noexcept
    : Strategy() {
    *this = ::std::move(from);
  }

  inline Strategy& operator=(const Strategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Strategy& operator=(Strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Strategy* internal_default_instance() {
    return reinterpret_cast<const Strategy*>(
               &_Strategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Strategy& a, Strategy& b) {
    a.Swap(&b);
  }
  inline void Swap(Strategy* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Strategy* New() const final {
    return CreateMaybeMessage<Strategy>(nullptr);
  }

  Strategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Strategy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Strategy& from);
  void MergeFrom(const Strategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Strategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.Strategy";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuyFieldNumber = 3,
    kSellFieldNumber = 4,
    kStoplossFieldNumber = 5,
    kTakeprofitFieldNumber = 6,
    kIndicatorsFieldNumber = 14,
    kNameFieldNumber = 1,
    kTitleFieldNumber = 13,
    kAssetFieldNumber = 2,
    kParamsBuyFieldNumber = 7,
    kParamsSellFieldNumber = 8,
    kParamsStopLossFieldNumber = 9,
    kParamsTakeProfitFieldNumber = 10,
    kParamsInitFieldNumber = 11,
    kParamsAIPFieldNumber = 12,
    kFeeBuyFieldNumber = 15,
    kFeeSellFieldNumber = 16,
  };
  // repeated .tradingpb.CtrlCondition buy = 3;
  int buy_size() const;
  private:
  int _internal_buy_size() const;
  public:
  void clear_buy();
  ::tradingpb::CtrlCondition* mutable_buy(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
      mutable_buy();
  private:
  const ::tradingpb::CtrlCondition& _internal_buy(int index) const;
  ::tradingpb::CtrlCondition* _internal_add_buy();
  public:
  const ::tradingpb::CtrlCondition& buy(int index) const;
  ::tradingpb::CtrlCondition* add_buy();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
      buy() const;

  // repeated .tradingpb.CtrlCondition sell = 4;
  int sell_size() const;
  private:
  int _internal_sell_size() const;
  public:
  void clear_sell();
  ::tradingpb::CtrlCondition* mutable_sell(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
      mutable_sell();
  private:
  const ::tradingpb::CtrlCondition& _internal_sell(int index) const;
  ::tradingpb::CtrlCondition* _internal_add_sell();
  public:
  const ::tradingpb::CtrlCondition& sell(int index) const;
  ::tradingpb::CtrlCondition* add_sell();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
      sell() const;

  // repeated .tradingpb.CtrlCondition stoploss = 5;
  int stoploss_size() const;
  private:
  int _internal_stoploss_size() const;
  public:
  void clear_stoploss();
  ::tradingpb::CtrlCondition* mutable_stoploss(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
      mutable_stoploss();
  private:
  const ::tradingpb::CtrlCondition& _internal_stoploss(int index) const;
  ::tradingpb::CtrlCondition* _internal_add_stoploss();
  public:
  const ::tradingpb::CtrlCondition& stoploss(int index) const;
  ::tradingpb::CtrlCondition* add_stoploss();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
      stoploss() const;

  // repeated .tradingpb.CtrlCondition takeprofit = 6;
  int takeprofit_size() const;
  private:
  int _internal_takeprofit_size() const;
  public:
  void clear_takeprofit();
  ::tradingpb::CtrlCondition* mutable_takeprofit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
      mutable_takeprofit();
  private:
  const ::tradingpb::CtrlCondition& _internal_takeprofit(int index) const;
  ::tradingpb::CtrlCondition* _internal_add_takeprofit();
  public:
  const ::tradingpb::CtrlCondition& takeprofit(int index) const;
  ::tradingpb::CtrlCondition* add_takeprofit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
      takeprofit() const;

  // repeated string indicators = 14;
  int indicators_size() const;
  private:
  int _internal_indicators_size() const;
  public:
  void clear_indicators();
  const std::string& indicators(int index) const;
  std::string* mutable_indicators(int index);
  void set_indicators(int index, const std::string& value);
  void set_indicators(int index, std::string&& value);
  void set_indicators(int index, const char* value);
  void set_indicators(int index, const char* value, size_t size);
  std::string* add_indicators();
  void add_indicators(const std::string& value);
  void add_indicators(std::string&& value);
  void add_indicators(const char* value);
  void add_indicators(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& indicators() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_indicators();
  private:
  const std::string& _internal_indicators(int index) const;
  std::string* _internal_add_indicators();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string title = 13 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_title();
  PROTOBUF_DEPRECATED const std::string& title() const;
  PROTOBUF_DEPRECATED void set_title(const std::string& value);
  PROTOBUF_DEPRECATED void set_title(std::string&& value);
  PROTOBUF_DEPRECATED void set_title(const char* value);
  PROTOBUF_DEPRECATED void set_title(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_title();
  PROTOBUF_DEPRECATED std::string* release_title();
  PROTOBUF_DEPRECATED void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // .tradingpb.Asset asset = 2;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::tradingpb::Asset& asset() const;
  ::tradingpb::Asset* release_asset();
  ::tradingpb::Asset* mutable_asset();
  void set_allocated_asset(::tradingpb::Asset* asset);
  private:
  const ::tradingpb::Asset& _internal_asset() const;
  ::tradingpb::Asset* _internal_mutable_asset();
  public:

  // .tradingpb.BuyParams paramsBuy = 7;
  bool has_paramsbuy() const;
  private:
  bool _internal_has_paramsbuy() const;
  public:
  void clear_paramsbuy();
  const ::tradingpb::BuyParams& paramsbuy() const;
  ::tradingpb::BuyParams* release_paramsbuy();
  ::tradingpb::BuyParams* mutable_paramsbuy();
  void set_allocated_paramsbuy(::tradingpb::BuyParams* paramsbuy);
  private:
  const ::tradingpb::BuyParams& _internal_paramsbuy() const;
  ::tradingpb::BuyParams* _internal_mutable_paramsbuy();
  public:

  // .tradingpb.SellParams paramsSell = 8;
  bool has_paramssell() const;
  private:
  bool _internal_has_paramssell() const;
  public:
  void clear_paramssell();
  const ::tradingpb::SellParams& paramssell() const;
  ::tradingpb::SellParams* release_paramssell();
  ::tradingpb::SellParams* mutable_paramssell();
  void set_allocated_paramssell(::tradingpb::SellParams* paramssell);
  private:
  const ::tradingpb::SellParams& _internal_paramssell() const;
  ::tradingpb::SellParams* _internal_mutable_paramssell();
  public:

  // .tradingpb.StopLossParams paramsStopLoss = 9;
  bool has_paramsstoploss() const;
  private:
  bool _internal_has_paramsstoploss() const;
  public:
  void clear_paramsstoploss();
  const ::tradingpb::StopLossParams& paramsstoploss() const;
  ::tradingpb::StopLossParams* release_paramsstoploss();
  ::tradingpb::StopLossParams* mutable_paramsstoploss();
  void set_allocated_paramsstoploss(::tradingpb::StopLossParams* paramsstoploss);
  private:
  const ::tradingpb::StopLossParams& _internal_paramsstoploss() const;
  ::tradingpb::StopLossParams* _internal_mutable_paramsstoploss();
  public:

  // .tradingpb.TakeProfitParams paramsTakeProfit = 10;
  bool has_paramstakeprofit() const;
  private:
  bool _internal_has_paramstakeprofit() const;
  public:
  void clear_paramstakeprofit();
  const ::tradingpb::TakeProfitParams& paramstakeprofit() const;
  ::tradingpb::TakeProfitParams* release_paramstakeprofit();
  ::tradingpb::TakeProfitParams* mutable_paramstakeprofit();
  void set_allocated_paramstakeprofit(::tradingpb::TakeProfitParams* paramstakeprofit);
  private:
  const ::tradingpb::TakeProfitParams& _internal_paramstakeprofit() const;
  ::tradingpb::TakeProfitParams* _internal_mutable_paramstakeprofit();
  public:

  // .tradingpb.InitParams paramsInit = 11;
  bool has_paramsinit() const;
  private:
  bool _internal_has_paramsinit() const;
  public:
  void clear_paramsinit();
  const ::tradingpb::InitParams& paramsinit() const;
  ::tradingpb::InitParams* release_paramsinit();
  ::tradingpb::InitParams* mutable_paramsinit();
  void set_allocated_paramsinit(::tradingpb::InitParams* paramsinit);
  private:
  const ::tradingpb::InitParams& _internal_paramsinit() const;
  ::tradingpb::InitParams* _internal_mutable_paramsinit();
  public:

  // .tradingpb.AIPParams paramsAIP = 12;
  bool has_paramsaip() const;
  private:
  bool _internal_has_paramsaip() const;
  public:
  void clear_paramsaip();
  const ::tradingpb::AIPParams& paramsaip() const;
  ::tradingpb::AIPParams* release_paramsaip();
  ::tradingpb::AIPParams* mutable_paramsaip();
  void set_allocated_paramsaip(::tradingpb::AIPParams* paramsaip);
  private:
  const ::tradingpb::AIPParams& _internal_paramsaip() const;
  ::tradingpb::AIPParams* _internal_mutable_paramsaip();
  public:

  // .tradingpb.FeeParams feeBuy = 15;
  bool has_feebuy() const;
  private:
  bool _internal_has_feebuy() const;
  public:
  void clear_feebuy();
  const ::tradingpb::FeeParams& feebuy() const;
  ::tradingpb::FeeParams* release_feebuy();
  ::tradingpb::FeeParams* mutable_feebuy();
  void set_allocated_feebuy(::tradingpb::FeeParams* feebuy);
  private:
  const ::tradingpb::FeeParams& _internal_feebuy() const;
  ::tradingpb::FeeParams* _internal_mutable_feebuy();
  public:

  // .tradingpb.FeeParams feeSell = 16;
  bool has_feesell() const;
  private:
  bool _internal_has_feesell() const;
  public:
  void clear_feesell();
  const ::tradingpb::FeeParams& feesell() const;
  ::tradingpb::FeeParams* release_feesell();
  ::tradingpb::FeeParams* mutable_feesell();
  void set_allocated_feesell(::tradingpb::FeeParams* feesell);
  private:
  const ::tradingpb::FeeParams& _internal_feesell() const;
  ::tradingpb::FeeParams* _internal_mutable_feesell();
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.Strategy)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition > buy_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition > sell_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition > stoploss_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition > takeprofit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> indicators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::tradingpb::Asset* asset_;
  ::tradingpb::BuyParams* paramsbuy_;
  ::tradingpb::SellParams* paramssell_;
  ::tradingpb::StopLossParams* paramsstoploss_;
  ::tradingpb::TakeProfitParams* paramstakeprofit_;
  ::tradingpb::InitParams* paramsinit_;
  ::tradingpb::AIPParams* paramsaip_;
  ::tradingpb::FeeParams* feebuy_;
  ::tradingpb::FeeParams* feesell_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class PNLDataValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.PNLDataValue) */ {
 public:
  PNLDataValue();
  virtual ~PNLDataValue();

  PNLDataValue(const PNLDataValue& from);
  PNLDataValue(PNLDataValue&& from) noexcept
    : PNLDataValue() {
    *this = ::std::move(from);
  }

  inline PNLDataValue& operator=(const PNLDataValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PNLDataValue& operator=(PNLDataValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PNLDataValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PNLDataValue* internal_default_instance() {
    return reinterpret_cast<const PNLDataValue*>(
               &_PNLDataValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PNLDataValue& a, PNLDataValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PNLDataValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PNLDataValue* New() const final {
    return CreateMaybeMessage<PNLDataValue>(nullptr);
  }

  PNLDataValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PNLDataValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PNLDataValue& from);
  void MergeFrom(const PNLDataValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNLDataValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.PNLDataValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kTsFieldNumber = 1,
    kPerValueFieldNumber = 2,
    kCostFieldNumber = 4,
    kValueFieldNumber = 5,
    kVolumeFieldNumber = 6,
    kPriceFieldNumber = 7,
  };
  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // int64 ts = 1;
  void clear_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 ts() const;
  void set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ts() const;
  void _internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float perValue = 2;
  void clear_pervalue();
  float pervalue() const;
  void set_pervalue(float value);
  private:
  float _internal_pervalue() const;
  void _internal_set_pervalue(float value);
  public:

  // float cost = 4;
  void clear_cost();
  float cost() const;
  void set_cost(float value);
  private:
  float _internal_cost() const;
  void _internal_set_cost(float value);
  public:

  // float value = 5;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // float volume = 6;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // float price = 7;
  void clear_price();
  float price() const;
  void set_price(float value);
  private:
  float _internal_price() const;
  void _internal_set_price(float value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.PNLDataValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::int64 ts_;
  float pervalue_;
  float cost_;
  float value_;
  float volume_;
  float price_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class PNLAssetData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.PNLAssetData) */ {
 public:
  PNLAssetData();
  virtual ~PNLAssetData();

  PNLAssetData(const PNLAssetData& from);
  PNLAssetData(PNLAssetData&& from) noexcept
    : PNLAssetData() {
    *this = ::std::move(from);
  }

  inline PNLAssetData& operator=(const PNLAssetData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PNLAssetData& operator=(PNLAssetData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PNLAssetData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PNLAssetData* internal_default_instance() {
    return reinterpret_cast<const PNLAssetData*>(
               &_PNLAssetData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PNLAssetData& a, PNLAssetData& b) {
    a.Swap(&b);
  }
  inline void Swap(PNLAssetData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PNLAssetData* New() const final {
    return CreateMaybeMessage<PNLAssetData>(nullptr);
  }

  PNLAssetData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PNLAssetData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PNLAssetData& from);
  void MergeFrom(const PNLAssetData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNLAssetData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.PNLAssetData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kLstCtrlFieldNumber = 33,
    kIndicatorsFieldNumber = 34,
    kAssetFieldNumber = 1,
    kMaxDrawdownStartTsFieldNumber = 4,
    kMaxDrawdownFieldNumber = 3,
    kMaxDrawupFieldNumber = 6,
    kMaxDrawdownEndTsFieldNumber = 5,
    kMaxDrawupStartTsFieldNumber = 7,
    kMaxDrawupEndTsFieldNumber = 8,
    kSharpeFieldNumber = 9,
    kAnnualizedReturnsFieldNumber = 10,
    kAnnualizedVolatilityFieldNumber = 11,
    kTotalReturnsFieldNumber = 12,
    kVarianceFieldNumber = 13,
    kBuyTimesFieldNumber = 14,
    kSellTimesFieldNumber = 15,
    kStoplossTimesFieldNumber = 16,
    kMaxUpDayTsFieldNumber = 17,
    kMaxDownDayTsFieldNumber = 19,
    kMaxPerUpDayFieldNumber = 18,
    kMaxPerDownDayFieldNumber = 20,
    kMaxUpWeekTsFieldNumber = 21,
    kMaxDownWeekTsFieldNumber = 23,
    kMaxPerUpWeekFieldNumber = 22,
    kMaxPerDownWeekFieldNumber = 24,
    kMaxUpMonthTsFieldNumber = 25,
    kMaxDownMonthTsFieldNumber = 27,
    kMaxPerUpMonthFieldNumber = 26,
    kMaxPerDownMonthFieldNumber = 28,
    kMaxUpYearTsFieldNumber = 29,
    kMaxDownYearTsFieldNumber = 31,
    kMaxPerUpYearFieldNumber = 30,
    kMaxPerDownYearFieldNumber = 32,
    kWinTimesFieldNumber = 35,
  };
  // repeated .tradingpb.PNLDataValue values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::tradingpb::PNLDataValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLDataValue >*
      mutable_values();
  private:
  const ::tradingpb::PNLDataValue& _internal_values(int index) const;
  ::tradingpb::PNLDataValue* _internal_add_values();
  public:
  const ::tradingpb::PNLDataValue& values(int index) const;
  ::tradingpb::PNLDataValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLDataValue >&
      values() const;

  // repeated .tradingpb.CtrlNode lstCtrl = 33;
  int lstctrl_size() const;
  private:
  int _internal_lstctrl_size() const;
  public:
  void clear_lstctrl();
  ::tradingpb::CtrlNode* mutable_lstctrl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlNode >*
      mutable_lstctrl();
  private:
  const ::tradingpb::CtrlNode& _internal_lstctrl(int index) const;
  ::tradingpb::CtrlNode* _internal_add_lstctrl();
  public:
  const ::tradingpb::CtrlNode& lstctrl(int index) const;
  ::tradingpb::CtrlNode* add_lstctrl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlNode >&
      lstctrl() const;

  // repeated .tradingpb.Indicator indicators = 34;
  int indicators_size() const;
  private:
  int _internal_indicators_size() const;
  public:
  void clear_indicators();
  ::tradingpb::Indicator* mutable_indicators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Indicator >*
      mutable_indicators();
  private:
  const ::tradingpb::Indicator& _internal_indicators(int index) const;
  ::tradingpb::Indicator* _internal_add_indicators();
  public:
  const ::tradingpb::Indicator& indicators(int index) const;
  ::tradingpb::Indicator* add_indicators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Indicator >&
      indicators() const;

  // .tradingpb.Asset asset = 1;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::tradingpb::Asset& asset() const;
  ::tradingpb::Asset* release_asset();
  ::tradingpb::Asset* mutable_asset();
  void set_allocated_asset(::tradingpb::Asset* asset);
  private:
  const ::tradingpb::Asset& _internal_asset() const;
  ::tradingpb::Asset* _internal_mutable_asset();
  public:

  // int64 maxDrawdownStartTs = 4;
  void clear_maxdrawdownstartts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawdownstartts() const;
  void set_maxdrawdownstartts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdrawdownstartts() const;
  void _internal_set_maxdrawdownstartts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float maxDrawdown = 3;
  void clear_maxdrawdown();
  float maxdrawdown() const;
  void set_maxdrawdown(float value);
  private:
  float _internal_maxdrawdown() const;
  void _internal_set_maxdrawdown(float value);
  public:

  // float maxDrawup = 6;
  void clear_maxdrawup();
  float maxdrawup() const;
  void set_maxdrawup(float value);
  private:
  float _internal_maxdrawup() const;
  void _internal_set_maxdrawup(float value);
  public:

  // int64 maxDrawdownEndTs = 5;
  void clear_maxdrawdownendts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawdownendts() const;
  void set_maxdrawdownendts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdrawdownendts() const;
  void _internal_set_maxdrawdownendts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 maxDrawupStartTs = 7;
  void clear_maxdrawupstartts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawupstartts() const;
  void set_maxdrawupstartts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdrawupstartts() const;
  void _internal_set_maxdrawupstartts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 maxDrawupEndTs = 8;
  void clear_maxdrawupendts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawupendts() const;
  void set_maxdrawupendts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdrawupendts() const;
  void _internal_set_maxdrawupendts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float sharpe = 9;
  void clear_sharpe();
  float sharpe() const;
  void set_sharpe(float value);
  private:
  float _internal_sharpe() const;
  void _internal_set_sharpe(float value);
  public:

  // float annualizedReturns = 10;
  void clear_annualizedreturns();
  float annualizedreturns() const;
  void set_annualizedreturns(float value);
  private:
  float _internal_annualizedreturns() const;
  void _internal_set_annualizedreturns(float value);
  public:

  // float annualizedVolatility = 11;
  void clear_annualizedvolatility();
  float annualizedvolatility() const;
  void set_annualizedvolatility(float value);
  private:
  float _internal_annualizedvolatility() const;
  void _internal_set_annualizedvolatility(float value);
  public:

  // float totalReturns = 12;
  void clear_totalreturns();
  float totalreturns() const;
  void set_totalreturns(float value);
  private:
  float _internal_totalreturns() const;
  void _internal_set_totalreturns(float value);
  public:

  // float variance = 13;
  void clear_variance();
  float variance() const;
  void set_variance(float value);
  private:
  float _internal_variance() const;
  void _internal_set_variance(float value);
  public:

  // int32 buyTimes = 14;
  void clear_buytimes();
  ::PROTOBUF_NAMESPACE_ID::int32 buytimes() const;
  void set_buytimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_buytimes() const;
  void _internal_set_buytimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sellTimes = 15;
  void clear_selltimes();
  ::PROTOBUF_NAMESPACE_ID::int32 selltimes() const;
  void set_selltimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_selltimes() const;
  void _internal_set_selltimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 stoplossTimes = 16;
  void clear_stoplosstimes();
  ::PROTOBUF_NAMESPACE_ID::int32 stoplosstimes() const;
  void set_stoplosstimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stoplosstimes() const;
  void _internal_set_stoplosstimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 maxUpDayTs = 17;
  void clear_maxupdayts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxupdayts() const;
  void set_maxupdayts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxupdayts() const;
  void _internal_set_maxupdayts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 maxDownDayTs = 19;
  void clear_maxdowndayts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdowndayts() const;
  void set_maxdowndayts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdowndayts() const;
  void _internal_set_maxdowndayts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float maxPerUpDay = 18;
  void clear_maxperupday();
  float maxperupday() const;
  void set_maxperupday(float value);
  private:
  float _internal_maxperupday() const;
  void _internal_set_maxperupday(float value);
  public:

  // float maxPerDownDay = 20;
  void clear_maxperdownday();
  float maxperdownday() const;
  void set_maxperdownday(float value);
  private:
  float _internal_maxperdownday() const;
  void _internal_set_maxperdownday(float value);
  public:

  // int64 maxUpWeekTs = 21;
  void clear_maxupweekts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxupweekts() const;
  void set_maxupweekts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxupweekts() const;
  void _internal_set_maxupweekts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 maxDownWeekTs = 23;
  void clear_maxdownweekts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdownweekts() const;
  void set_maxdownweekts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdownweekts() const;
  void _internal_set_maxdownweekts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float maxPerUpWeek = 22;
  void clear_maxperupweek();
  float maxperupweek() const;
  void set_maxperupweek(float value);
  private:
  float _internal_maxperupweek() const;
  void _internal_set_maxperupweek(float value);
  public:

  // float maxPerDownWeek = 24;
  void clear_maxperdownweek();
  float maxperdownweek() const;
  void set_maxperdownweek(float value);
  private:
  float _internal_maxperdownweek() const;
  void _internal_set_maxperdownweek(float value);
  public:

  // int64 maxUpMonthTs = 25;
  void clear_maxupmonthts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxupmonthts() const;
  void set_maxupmonthts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxupmonthts() const;
  void _internal_set_maxupmonthts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 maxDownMonthTs = 27;
  void clear_maxdownmonthts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdownmonthts() const;
  void set_maxdownmonthts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdownmonthts() const;
  void _internal_set_maxdownmonthts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float maxPerUpMonth = 26;
  void clear_maxperupmonth();
  float maxperupmonth() const;
  void set_maxperupmonth(float value);
  private:
  float _internal_maxperupmonth() const;
  void _internal_set_maxperupmonth(float value);
  public:

  // float maxPerDownMonth = 28;
  void clear_maxperdownmonth();
  float maxperdownmonth() const;
  void set_maxperdownmonth(float value);
  private:
  float _internal_maxperdownmonth() const;
  void _internal_set_maxperdownmonth(float value);
  public:

  // int64 maxUpYearTs = 29;
  void clear_maxupyearts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxupyearts() const;
  void set_maxupyearts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxupyearts() const;
  void _internal_set_maxupyearts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 maxDownYearTs = 31;
  void clear_maxdownyearts();
  ::PROTOBUF_NAMESPACE_ID::int64 maxdownyearts() const;
  void set_maxdownyearts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_maxdownyearts() const;
  void _internal_set_maxdownyearts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float maxPerUpYear = 30;
  void clear_maxperupyear();
  float maxperupyear() const;
  void set_maxperupyear(float value);
  private:
  float _internal_maxperupyear() const;
  void _internal_set_maxperupyear(float value);
  public:

  // float maxPerDownYear = 32;
  void clear_maxperdownyear();
  float maxperdownyear() const;
  void set_maxperdownyear(float value);
  private:
  float _internal_maxperdownyear() const;
  void _internal_set_maxperdownyear(float value);
  public:

  // int32 winTimes = 35;
  void clear_wintimes();
  ::PROTOBUF_NAMESPACE_ID::int32 wintimes() const;
  void set_wintimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wintimes() const;
  void _internal_set_wintimes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.PNLAssetData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLDataValue > values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlNode > lstctrl_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Indicator > indicators_;
  ::tradingpb::Asset* asset_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawdownstartts_;
  float maxdrawdown_;
  float maxdrawup_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawdownendts_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawupstartts_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdrawupendts_;
  float sharpe_;
  float annualizedreturns_;
  float annualizedvolatility_;
  float totalreturns_;
  float variance_;
  ::PROTOBUF_NAMESPACE_ID::int32 buytimes_;
  ::PROTOBUF_NAMESPACE_ID::int32 selltimes_;
  ::PROTOBUF_NAMESPACE_ID::int32 stoplosstimes_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxupdayts_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdowndayts_;
  float maxperupday_;
  float maxperdownday_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxupweekts_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdownweekts_;
  float maxperupweek_;
  float maxperdownweek_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxupmonthts_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdownmonthts_;
  float maxperupmonth_;
  float maxperdownmonth_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxupyearts_;
  ::PROTOBUF_NAMESPACE_ID::int64 maxdownyearts_;
  float maxperupyear_;
  float maxperdownyear_;
  ::PROTOBUF_NAMESPACE_ID::int32 wintimes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class PNLData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.PNLData) */ {
 public:
  PNLData();
  virtual ~PNLData();

  PNLData(const PNLData& from);
  PNLData(PNLData&& from) noexcept
    : PNLData() {
    *this = ::std::move(from);
  }

  inline PNLData& operator=(const PNLData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PNLData& operator=(PNLData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PNLData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PNLData* internal_default_instance() {
    return reinterpret_cast<const PNLData*>(
               &_PNLData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PNLData& a, PNLData& b) {
    a.Swap(&b);
  }
  inline void Swap(PNLData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PNLData* New() const final {
    return CreateMaybeMessage<PNLData>(nullptr);
  }

  PNLData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PNLData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PNLData& from);
  void MergeFrom(const PNLData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNLData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.PNLData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetsFieldNumber = 3,
    kNameFieldNumber = 1,
    kTitleFieldNumber = 4,
    kTotalFieldNumber = 2,
    kLasttsFieldNumber = 5,
  };
  // repeated .tradingpb.PNLAssetData assets = 3 [deprecated = true];
  PROTOBUF_DEPRECATED int assets_size() const;
  private:
  int _internal_assets_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_assets();
  PROTOBUF_DEPRECATED ::tradingpb::PNLAssetData* mutable_assets(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLAssetData >*
      mutable_assets();
  private:
  const ::tradingpb::PNLAssetData& _internal_assets(int index) const;
  ::tradingpb::PNLAssetData* _internal_add_assets();
  public:
  PROTOBUF_DEPRECATED const ::tradingpb::PNLAssetData& assets(int index) const;
  PROTOBUF_DEPRECATED ::tradingpb::PNLAssetData* add_assets();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLAssetData >&
      assets() const;

  // string name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_name();
  PROTOBUF_DEPRECATED const std::string& name() const;
  PROTOBUF_DEPRECATED void set_name(const std::string& value);
  PROTOBUF_DEPRECATED void set_name(std::string&& value);
  PROTOBUF_DEPRECATED void set_name(const char* value);
  PROTOBUF_DEPRECATED void set_name(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_name();
  PROTOBUF_DEPRECATED std::string* release_name();
  PROTOBUF_DEPRECATED void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string title = 4;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // .tradingpb.PNLAssetData total = 2;
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  const ::tradingpb::PNLAssetData& total() const;
  ::tradingpb::PNLAssetData* release_total();
  ::tradingpb::PNLAssetData* mutable_total();
  void set_allocated_total(::tradingpb::PNLAssetData* total);
  private:
  const ::tradingpb::PNLAssetData& _internal_total() const;
  ::tradingpb::PNLAssetData* _internal_mutable_total();
  public:

  // int64 lastts = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_lastts();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int64 lastts() const;
  PROTOBUF_DEPRECATED void set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_lastts() const;
  void _internal_set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.PNLData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLAssetData > assets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::tradingpb::PNLAssetData* total_;
  ::PROTOBUF_NAMESPACE_ID::int64 lastts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class SimTradingParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.SimTradingParams) */ {
 public:
  SimTradingParams();
  virtual ~SimTradingParams();

  SimTradingParams(const SimTradingParams& from);
  SimTradingParams(SimTradingParams&& from) noexcept
    : SimTradingParams() {
    *this = ::std::move(from);
  }

  inline SimTradingParams& operator=(const SimTradingParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimTradingParams& operator=(SimTradingParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimTradingParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimTradingParams* internal_default_instance() {
    return reinterpret_cast<const SimTradingParams*>(
               &_SimTradingParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SimTradingParams& a, SimTradingParams& b) {
    a.Swap(&b);
  }
  inline void Swap(SimTradingParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimTradingParams* New() const final {
    return CreateMaybeMessage<SimTradingParams>(nullptr);
  }

  SimTradingParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimTradingParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimTradingParams& from);
  void MergeFrom(const SimTradingParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimTradingParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.SimTradingParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetsFieldNumber = 1,
    kBaselinesFieldNumber = 2,
    kStrategiesFieldNumber = 5,
    kIndicatorsFieldNumber = 9,
    kTitleFieldNumber = 7,
    kWalletFieldNumber = 6,
    kStartTsFieldNumber = 3,
    kEndTsFieldNumber = 4,
    kMainAssetIndexFieldNumber = 8,
    kOffsetFieldNumber = 10,
  };
  // repeated .tradingpb.Asset assets = 1;
  int assets_size() const;
  private:
  int _internal_assets_size() const;
  public:
  void clear_assets();
  ::tradingpb::Asset* mutable_assets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >*
      mutable_assets();
  private:
  const ::tradingpb::Asset& _internal_assets(int index) const;
  ::tradingpb::Asset* _internal_add_assets();
  public:
  const ::tradingpb::Asset& assets(int index) const;
  ::tradingpb::Asset* add_assets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >&
      assets() const;

  // repeated .tradingpb.Asset baselines = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int baselines_size() const;
  private:
  int _internal_baselines_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_baselines();
  PROTOBUF_DEPRECATED ::tradingpb::Asset* mutable_baselines(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >*
      mutable_baselines();
  private:
  const ::tradingpb::Asset& _internal_baselines(int index) const;
  ::tradingpb::Asset* _internal_add_baselines();
  public:
  PROTOBUF_DEPRECATED const ::tradingpb::Asset& baselines(int index) const;
  PROTOBUF_DEPRECATED ::tradingpb::Asset* add_baselines();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >&
      baselines() const;

  // repeated .tradingpb.Strategy strategies = 5;
  int strategies_size() const;
  private:
  int _internal_strategies_size() const;
  public:
  void clear_strategies();
  ::tradingpb::Strategy* mutable_strategies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Strategy >*
      mutable_strategies();
  private:
  const ::tradingpb::Strategy& _internal_strategies(int index) const;
  ::tradingpb::Strategy* _internal_add_strategies();
  public:
  const ::tradingpb::Strategy& strategies(int index) const;
  ::tradingpb::Strategy* add_strategies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Strategy >&
      strategies() const;

  // repeated string indicators = 9;
  int indicators_size() const;
  private:
  int _internal_indicators_size() const;
  public:
  void clear_indicators();
  const std::string& indicators(int index) const;
  std::string* mutable_indicators(int index);
  void set_indicators(int index, const std::string& value);
  void set_indicators(int index, std::string&& value);
  void set_indicators(int index, const char* value);
  void set_indicators(int index, const char* value, size_t size);
  std::string* add_indicators();
  void add_indicators(const std::string& value);
  void add_indicators(std::string&& value);
  void add_indicators(const char* value);
  void add_indicators(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& indicators() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_indicators();
  private:
  const std::string& _internal_indicators(int index) const;
  std::string* _internal_add_indicators();
  public:

  // string title = 7;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // .tradingpb.Wallet wallet = 6;
  bool has_wallet() const;
  private:
  bool _internal_has_wallet() const;
  public:
  void clear_wallet();
  const ::tradingpb::Wallet& wallet() const;
  ::tradingpb::Wallet* release_wallet();
  ::tradingpb::Wallet* mutable_wallet();
  void set_allocated_wallet(::tradingpb::Wallet* wallet);
  private:
  const ::tradingpb::Wallet& _internal_wallet() const;
  ::tradingpb::Wallet* _internal_mutable_wallet();
  public:

  // int64 startTs = 3;
  void clear_startts();
  ::PROTOBUF_NAMESPACE_ID::int64 startts() const;
  void set_startts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_startts() const;
  void _internal_set_startts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 endTs = 4;
  void clear_endts();
  ::PROTOBUF_NAMESPACE_ID::int64 endts() const;
  void set_endts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_endts() const;
  void _internal_set_endts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 mainAssetIndex = 8;
  void clear_mainassetindex();
  ::PROTOBUF_NAMESPACE_ID::int32 mainassetindex() const;
  void set_mainassetindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mainassetindex() const;
  void _internal_set_mainassetindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 offset = 10;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.SimTradingParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset > assets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset > baselines_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Strategy > strategies_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> indicators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::tradingpb::Wallet* wallet_;
  ::PROTOBUF_NAMESPACE_ID::int64 startts_;
  ::PROTOBUF_NAMESPACE_ID::int64 endts_;
  ::PROTOBUF_NAMESPACE_ID::int32 mainassetindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class TradingNodeInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.TradingNodeInfo) */ {
 public:
  TradingNodeInfo();
  virtual ~TradingNodeInfo();

  TradingNodeInfo(const TradingNodeInfo& from);
  TradingNodeInfo(TradingNodeInfo&& from) noexcept
    : TradingNodeInfo() {
    *this = ::std::move(from);
  }

  inline TradingNodeInfo& operator=(const TradingNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingNodeInfo& operator=(TradingNodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TradingNodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradingNodeInfo* internal_default_instance() {
    return reinterpret_cast<const TradingNodeInfo*>(
               &_TradingNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TradingNodeInfo& a, TradingNodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingNodeInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TradingNodeInfo* New() const final {
    return CreateMaybeMessage<TradingNodeInfo>(nullptr);
  }

  TradingNodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TradingNodeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TradingNodeInfo& from);
  void MergeFrom(const TradingNodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingNodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.TradingNodeInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxTasksFieldNumber = 1,
    kCurTasksFieldNumber = 2,
  };
  // int32 maxTasks = 1;
  void clear_maxtasks();
  ::PROTOBUF_NAMESPACE_ID::int32 maxtasks() const;
  void set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxtasks() const;
  void _internal_set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curTasks = 2;
  void clear_curtasks();
  ::PROTOBUF_NAMESPACE_ID::int32 curtasks() const;
  void set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curtasks() const;
  void _internal_set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.TradingNodeInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxtasks_;
  ::PROTOBUF_NAMESPACE_ID::int32 curtasks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class SimTradingCacheNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.SimTradingCacheNode) */ {
 public:
  SimTradingCacheNode();
  virtual ~SimTradingCacheNode();

  SimTradingCacheNode(const SimTradingCacheNode& from);
  SimTradingCacheNode(SimTradingCacheNode&& from) noexcept
    : SimTradingCacheNode() {
    *this = ::std::move(from);
  }

  inline SimTradingCacheNode& operator=(const SimTradingCacheNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimTradingCacheNode& operator=(SimTradingCacheNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimTradingCacheNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimTradingCacheNode* internal_default_instance() {
    return reinterpret_cast<const SimTradingCacheNode*>(
               &_SimTradingCacheNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SimTradingCacheNode& a, SimTradingCacheNode& b) {
    a.Swap(&b);
  }
  inline void Swap(SimTradingCacheNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimTradingCacheNode* New() const final {
    return CreateMaybeMessage<SimTradingCacheNode>(nullptr);
  }

  SimTradingCacheNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimTradingCacheNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimTradingCacheNode& from);
  void MergeFrom(const SimTradingCacheNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimTradingCacheNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.SimTradingCacheNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kHashFieldNumber = 4,
    kBufFieldNumber = 5,
    kParamsFieldNumber = 1,
    kLastTsFieldNumber = 3,
  };
  // string key = 2;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string hash = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_hash();
  PROTOBUF_DEPRECATED const std::string& hash() const;
  PROTOBUF_DEPRECATED void set_hash(const std::string& value);
  PROTOBUF_DEPRECATED void set_hash(std::string&& value);
  PROTOBUF_DEPRECATED void set_hash(const char* value);
  PROTOBUF_DEPRECATED void set_hash(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_hash();
  PROTOBUF_DEPRECATED std::string* release_hash();
  PROTOBUF_DEPRECATED void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bytes buf = 5;
  void clear_buf();
  const std::string& buf() const;
  void set_buf(const std::string& value);
  void set_buf(std::string&& value);
  void set_buf(const char* value);
  void set_buf(const void* value, size_t size);
  std::string* mutable_buf();
  std::string* release_buf();
  void set_allocated_buf(std::string* buf);
  private:
  const std::string& _internal_buf() const;
  void _internal_set_buf(const std::string& value);
  std::string* _internal_mutable_buf();
  public:

  // .tradingpb.SimTradingParams params = 1;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::tradingpb::SimTradingParams& params() const;
  ::tradingpb::SimTradingParams* release_params();
  ::tradingpb::SimTradingParams* mutable_params();
  void set_allocated_params(::tradingpb::SimTradingParams* params);
  private:
  const ::tradingpb::SimTradingParams& _internal_params() const;
  ::tradingpb::SimTradingParams* _internal_mutable_params();
  public:

  // int64 lastTs = 3;
  void clear_lastts();
  ::PROTOBUF_NAMESPACE_ID::int64 lastts() const;
  void set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_lastts() const;
  void _internal_set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.SimTradingCacheNode)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buf_;
  ::tradingpb::SimTradingParams* params_;
  ::PROTOBUF_NAMESPACE_ID::int64 lastts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// -------------------------------------------------------------------

class SimTradingCache :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.SimTradingCache) */ {
 public:
  SimTradingCache();
  virtual ~SimTradingCache();

  SimTradingCache(const SimTradingCache& from);
  SimTradingCache(SimTradingCache&& from) noexcept
    : SimTradingCache() {
    *this = ::std::move(from);
  }

  inline SimTradingCache& operator=(const SimTradingCache& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimTradingCache& operator=(SimTradingCache&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimTradingCache& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimTradingCache* internal_default_instance() {
    return reinterpret_cast<const SimTradingCache*>(
               &_SimTradingCache_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SimTradingCache& a, SimTradingCache& b) {
    a.Swap(&b);
  }
  inline void Swap(SimTradingCache* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimTradingCache* New() const final {
    return CreateMaybeMessage<SimTradingCache>(nullptr);
  }

  SimTradingCache* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimTradingCache>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimTradingCache& from);
  void MergeFrom(const SimTradingCache& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimTradingCache* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.SimTradingCache";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_trading2_2eproto);
    return ::descriptor_table_trading2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .tradingpb.SimTradingCacheNode nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::tradingpb::SimTradingCacheNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::SimTradingCacheNode >*
      mutable_nodes();
  private:
  const ::tradingpb::SimTradingCacheNode& _internal_nodes(int index) const;
  ::tradingpb::SimTradingCacheNode* _internal_add_nodes();
  public:
  const ::tradingpb::SimTradingCacheNode& nodes(int index) const;
  ::tradingpb::SimTradingCacheNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::SimTradingCacheNode >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:tradingpb.SimTradingCache)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::SimTradingCacheNode > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_trading2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BasicRequestData

// string token = 1;
inline void BasicRequestData::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BasicRequestData::token() const {
  // @@protoc_insertion_point(field_get:tradingpb.BasicRequestData.token)
  return _internal_token();
}
inline void BasicRequestData::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:tradingpb.BasicRequestData.token)
}
inline std::string* BasicRequestData::mutable_token() {
  // @@protoc_insertion_point(field_mutable:tradingpb.BasicRequestData.token)
  return _internal_mutable_token();
}
inline const std::string& BasicRequestData::_internal_token() const {
  return token_.GetNoArena();
}
inline void BasicRequestData::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BasicRequestData::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.BasicRequestData.token)
}
inline void BasicRequestData::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.BasicRequestData.token)
}
inline void BasicRequestData::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.BasicRequestData.token)
}
inline std::string* BasicRequestData::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BasicRequestData::release_token() {
  // @@protoc_insertion_point(field_release:tradingpb.BasicRequestData.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BasicRequestData::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.BasicRequestData.token)
}

// -------------------------------------------------------------------

// Asset

// string market = 1;
inline void Asset::clear_market() {
  market_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Asset::market() const {
  // @@protoc_insertion_point(field_get:tradingpb.Asset.market)
  return _internal_market();
}
inline void Asset::set_market(const std::string& value) {
  _internal_set_market(value);
  // @@protoc_insertion_point(field_set:tradingpb.Asset.market)
}
inline std::string* Asset::mutable_market() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Asset.market)
  return _internal_mutable_market();
}
inline const std::string& Asset::_internal_market() const {
  return market_.GetNoArena();
}
inline void Asset::_internal_set_market(const std::string& value) {
  
  market_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Asset::set_market(std::string&& value) {
  
  market_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.Asset.market)
}
inline void Asset::set_market(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  market_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.Asset.market)
}
inline void Asset::set_market(const char* value, size_t size) {
  
  market_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Asset.market)
}
inline std::string* Asset::_internal_mutable_market() {
  
  return market_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Asset::release_market() {
  // @@protoc_insertion_point(field_release:tradingpb.Asset.market)
  
  return market_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_market(std::string* market) {
  if (market != nullptr) {
    
  } else {
    
  }
  market_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), market);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Asset.market)
}

// string code = 2;
inline void Asset::clear_code() {
  code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Asset::code() const {
  // @@protoc_insertion_point(field_get:tradingpb.Asset.code)
  return _internal_code();
}
inline void Asset::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tradingpb.Asset.code)
}
inline std::string* Asset::mutable_code() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Asset.code)
  return _internal_mutable_code();
}
inline const std::string& Asset::_internal_code() const {
  return code_.GetNoArena();
}
inline void Asset::_internal_set_code(const std::string& value) {
  
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Asset::set_code(std::string&& value) {
  
  code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.Asset.code)
}
inline void Asset::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.Asset.code)
}
inline void Asset::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Asset.code)
}
inline std::string* Asset::_internal_mutable_code() {
  
  return code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Asset::release_code() {
  // @@protoc_insertion_point(field_release:tradingpb.Asset.code)
  
  return code_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Asset.code)
}

// repeated string tags = 3;
inline int Asset::_internal_tags_size() const {
  return tags_.size();
}
inline int Asset::tags_size() const {
  return _internal_tags_size();
}
inline void Asset::clear_tags() {
  tags_.Clear();
}
inline std::string* Asset::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:tradingpb.Asset.tags)
  return _internal_add_tags();
}
inline const std::string& Asset::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& Asset::tags(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Asset.tags)
  return _internal_tags(index);
}
inline std::string* Asset::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Asset.tags)
  return tags_.Mutable(index);
}
inline void Asset::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tradingpb.Asset.tags)
  tags_.Mutable(index)->assign(value);
}
inline void Asset::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tradingpb.Asset.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void Asset::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tradingpb.Asset.tags)
}
inline void Asset::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Asset.tags)
}
inline std::string* Asset::_internal_add_tags() {
  return tags_.Add();
}
inline void Asset::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tradingpb.Asset.tags)
}
inline void Asset::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tradingpb.Asset.tags)
}
inline void Asset::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tradingpb.Asset.tags)
}
inline void Asset::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tradingpb.Asset.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Asset::tags() const {
  // @@protoc_insertion_point(field_list:tradingpb.Asset.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Asset::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Asset.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// CtrlNodeAssetInfo

// double volume = 1;
inline void CtrlNodeAssetInfo::clear_volume() {
  volume_ = 0;
}
inline double CtrlNodeAssetInfo::_internal_volume() const {
  return volume_;
}
inline double CtrlNodeAssetInfo::volume() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNodeAssetInfo.volume)
  return _internal_volume();
}
inline void CtrlNodeAssetInfo::_internal_set_volume(double value) {
  
  volume_ = value;
}
inline void CtrlNodeAssetInfo::set_volume(double value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNodeAssetInfo.volume)
}

// double cost = 2;
inline void CtrlNodeAssetInfo::clear_cost() {
  cost_ = 0;
}
inline double CtrlNodeAssetInfo::_internal_cost() const {
  return cost_;
}
inline double CtrlNodeAssetInfo::cost() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNodeAssetInfo.cost)
  return _internal_cost();
}
inline void CtrlNodeAssetInfo::_internal_set_cost(double value) {
  
  cost_ = value;
}
inline void CtrlNodeAssetInfo::set_cost(double value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNodeAssetInfo.cost)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CtrlNode

// int64 ts = 1;
inline void CtrlNode::clear_ts() {
  ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CtrlNode::_internal_ts() const {
  return ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CtrlNode::ts() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.ts)
  return _internal_ts();
}
inline void CtrlNode::_internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ts_ = value;
}
inline void CtrlNode::set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.ts)
}

// .tradingpb.Asset src = 2;
inline bool CtrlNode::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool CtrlNode::has_src() const {
  return _internal_has_src();
}
inline void CtrlNode::clear_src() {
  if (GetArenaNoVirtual() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::tradingpb::Asset& CtrlNode::_internal_src() const {
  const ::tradingpb::Asset* p = src_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::Asset*>(
      &::tradingpb::_Asset_default_instance_);
}
inline const ::tradingpb::Asset& CtrlNode::src() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.src)
  return _internal_src();
}
inline ::tradingpb::Asset* CtrlNode::release_src() {
  // @@protoc_insertion_point(field_release:tradingpb.CtrlNode.src)
  
  ::tradingpb::Asset* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::tradingpb::Asset* CtrlNode::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::Asset>(GetArenaNoVirtual());
    src_ = p;
  }
  return src_;
}
inline ::tradingpb::Asset* CtrlNode::mutable_src() {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlNode.src)
  return _internal_mutable_src();
}
inline void CtrlNode::set_allocated_src(::tradingpb::Asset* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.CtrlNode.src)
}

// .tradingpb.Asset dst = 3;
inline bool CtrlNode::_internal_has_dst() const {
  return this != internal_default_instance() && dst_ != nullptr;
}
inline bool CtrlNode::has_dst() const {
  return _internal_has_dst();
}
inline void CtrlNode::clear_dst() {
  if (GetArenaNoVirtual() == nullptr && dst_ != nullptr) {
    delete dst_;
  }
  dst_ = nullptr;
}
inline const ::tradingpb::Asset& CtrlNode::_internal_dst() const {
  const ::tradingpb::Asset* p = dst_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::Asset*>(
      &::tradingpb::_Asset_default_instance_);
}
inline const ::tradingpb::Asset& CtrlNode::dst() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.dst)
  return _internal_dst();
}
inline ::tradingpb::Asset* CtrlNode::release_dst() {
  // @@protoc_insertion_point(field_release:tradingpb.CtrlNode.dst)
  
  ::tradingpb::Asset* temp = dst_;
  dst_ = nullptr;
  return temp;
}
inline ::tradingpb::Asset* CtrlNode::_internal_mutable_dst() {
  
  if (dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::Asset>(GetArenaNoVirtual());
    dst_ = p;
  }
  return dst_;
}
inline ::tradingpb::Asset* CtrlNode::mutable_dst() {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlNode.dst)
  return _internal_mutable_dst();
}
inline void CtrlNode::set_allocated_dst(::tradingpb::Asset* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dst_;
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    
  } else {
    
  }
  dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.CtrlNode.dst)
}

// double volumeSrc = 4;
inline void CtrlNode::clear_volumesrc() {
  volumesrc_ = 0;
}
inline double CtrlNode::_internal_volumesrc() const {
  return volumesrc_;
}
inline double CtrlNode::volumesrc() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.volumeSrc)
  return _internal_volumesrc();
}
inline void CtrlNode::_internal_set_volumesrc(double value) {
  
  volumesrc_ = value;
}
inline void CtrlNode::set_volumesrc(double value) {
  _internal_set_volumesrc(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.volumeSrc)
}

// double volumeDst = 5;
inline void CtrlNode::clear_volumedst() {
  volumedst_ = 0;
}
inline double CtrlNode::_internal_volumedst() const {
  return volumedst_;
}
inline double CtrlNode::volumedst() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.volumeDst)
  return _internal_volumedst();
}
inline void CtrlNode::_internal_set_volumedst(double value) {
  
  volumedst_ = value;
}
inline void CtrlNode::set_volumedst(double value) {
  _internal_set_volumedst(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.volumeDst)
}

// .tradingpb.CtrlType type = 6;
inline void CtrlNode::clear_type() {
  type_ = 0;
}
inline ::tradingpb::CtrlType CtrlNode::_internal_type() const {
  return static_cast< ::tradingpb::CtrlType >(type_);
}
inline ::tradingpb::CtrlType CtrlNode::type() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.type)
  return _internal_type();
}
inline void CtrlNode::_internal_set_type(::tradingpb::CtrlType value) {
  
  type_ = value;
}
inline void CtrlNode::set_type(::tradingpb::CtrlType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.type)
}

// double fee = 7;
inline void CtrlNode::clear_fee() {
  fee_ = 0;
}
inline double CtrlNode::_internal_fee() const {
  return fee_;
}
inline double CtrlNode::fee() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.fee)
  return _internal_fee();
}
inline void CtrlNode::_internal_set_fee(double value) {
  
  fee_ = value;
}
inline void CtrlNode::set_fee(double value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.fee)
}

// double averageHoldingPrice = 8;
inline void CtrlNode::clear_averageholdingprice() {
  averageholdingprice_ = 0;
}
inline double CtrlNode::_internal_averageholdingprice() const {
  return averageholdingprice_;
}
inline double CtrlNode::averageholdingprice() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.averageHoldingPrice)
  return _internal_averageholdingprice();
}
inline void CtrlNode::_internal_set_averageholdingprice(double value) {
  
  averageholdingprice_ = value;
}
inline void CtrlNode::set_averageholdingprice(double value) {
  _internal_set_averageholdingprice(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.averageHoldingPrice)
}

// double sellPrice = 9;
inline void CtrlNode::clear_sellprice() {
  sellprice_ = 0;
}
inline double CtrlNode::_internal_sellprice() const {
  return sellprice_;
}
inline double CtrlNode::sellprice() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.sellPrice)
  return _internal_sellprice();
}
inline void CtrlNode::_internal_set_sellprice(double value) {
  
  sellprice_ = value;
}
inline void CtrlNode::set_sellprice(double value) {
  _internal_set_sellprice(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.sellPrice)
}

// int32 ctrlConditionID = 10;
inline void CtrlNode::clear_ctrlconditionid() {
  ctrlconditionid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::_internal_ctrlconditionid() const {
  return ctrlconditionid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::ctrlconditionid() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.ctrlConditionID)
  return _internal_ctrlconditionid();
}
inline void CtrlNode::_internal_set_ctrlconditionid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ctrlconditionid_ = value;
}
inline void CtrlNode::set_ctrlconditionid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ctrlconditionid(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.ctrlConditionID)
}

// int32 strategyID = 11;
inline void CtrlNode::clear_strategyid() {
  strategyid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::_internal_strategyid() const {
  return strategyid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::strategyid() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.strategyID)
  return _internal_strategyid();
}
inline void CtrlNode::_internal_set_strategyid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  strategyid_ = value;
}
inline void CtrlNode::set_strategyid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_strategyid(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.strategyID)
}

// double totalMoney = 12;
inline void CtrlNode::clear_totalmoney() {
  totalmoney_ = 0;
}
inline double CtrlNode::_internal_totalmoney() const {
  return totalmoney_;
}
inline double CtrlNode::totalmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.totalMoney)
  return _internal_totalmoney();
}
inline void CtrlNode::_internal_set_totalmoney(double value) {
  
  totalmoney_ = value;
}
inline void CtrlNode::set_totalmoney(double value) {
  _internal_set_totalmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.totalMoney)
}

// double lastMoney = 13;
inline void CtrlNode::clear_lastmoney() {
  lastmoney_ = 0;
}
inline double CtrlNode::_internal_lastmoney() const {
  return lastmoney_;
}
inline double CtrlNode::lastmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.lastMoney)
  return _internal_lastmoney();
}
inline void CtrlNode::_internal_set_lastmoney(double value) {
  
  lastmoney_ = value;
}
inline void CtrlNode::set_lastmoney(double value) {
  _internal_set_lastmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.lastMoney)
}

// map<string, .tradingpb.CtrlNodeAssetInfo> mapAssetsInfo = 14;
inline int CtrlNode::_internal_mapassetsinfo_size() const {
  return mapassetsinfo_.size();
}
inline int CtrlNode::mapassetsinfo_size() const {
  return _internal_mapassetsinfo_size();
}
inline void CtrlNode::clear_mapassetsinfo() {
  mapassetsinfo_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >&
CtrlNode::_internal_mapassetsinfo() const {
  return mapassetsinfo_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >&
CtrlNode::mapassetsinfo() const {
  // @@protoc_insertion_point(field_map:tradingpb.CtrlNode.mapAssetsInfo)
  return _internal_mapassetsinfo();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >*
CtrlNode::_internal_mutable_mapassetsinfo() {
  return mapassetsinfo_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tradingpb::CtrlNodeAssetInfo >*
CtrlNode::mutable_mapassetsinfo() {
  // @@protoc_insertion_point(field_mutable_map:tradingpb.CtrlNode.mapAssetsInfo)
  return _internal_mutable_mapassetsinfo();
}

// int32 moneyParts = 15;
inline void CtrlNode::clear_moneyparts() {
  moneyparts_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::_internal_moneyparts() const {
  return moneyparts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::moneyparts() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.moneyParts)
  return _internal_moneyparts();
}
inline void CtrlNode::_internal_set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  moneyparts_ = value;
}
inline void CtrlNode::set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_moneyparts(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.moneyParts)
}

// int32 lastMoneyParts = 16;
inline void CtrlNode::clear_lastmoneyparts() {
  lastmoneyparts_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::_internal_lastmoneyparts() const {
  return lastmoneyparts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlNode::lastmoneyparts() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlNode.lastMoneyParts)
  return _internal_lastmoneyparts();
}
inline void CtrlNode::_internal_set_lastmoneyparts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lastmoneyparts_ = value;
}
inline void CtrlNode::set_lastmoneyparts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lastmoneyparts(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlNode.lastMoneyParts)
}

// -------------------------------------------------------------------

// WalletAsset

// .tradingpb.Asset asset = 1;
inline bool WalletAsset::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool WalletAsset::has_asset() const {
  return _internal_has_asset();
}
inline void WalletAsset::clear_asset() {
  if (GetArenaNoVirtual() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::tradingpb::Asset& WalletAsset::_internal_asset() const {
  const ::tradingpb::Asset* p = asset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::Asset*>(
      &::tradingpb::_Asset_default_instance_);
}
inline const ::tradingpb::Asset& WalletAsset::asset() const {
  // @@protoc_insertion_point(field_get:tradingpb.WalletAsset.asset)
  return _internal_asset();
}
inline ::tradingpb::Asset* WalletAsset::release_asset() {
  // @@protoc_insertion_point(field_release:tradingpb.WalletAsset.asset)
  
  ::tradingpb::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::tradingpb::Asset* WalletAsset::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::Asset>(GetArenaNoVirtual());
    asset_ = p;
  }
  return asset_;
}
inline ::tradingpb::Asset* WalletAsset::mutable_asset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.WalletAsset.asset)
  return _internal_mutable_asset();
}
inline void WalletAsset::set_allocated_asset(::tradingpb::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.WalletAsset.asset)
}

// double value = 2;
inline void WalletAsset::clear_value() {
  value_ = 0;
}
inline double WalletAsset::_internal_value() const {
  return value_;
}
inline double WalletAsset::value() const {
  // @@protoc_insertion_point(field_get:tradingpb.WalletAsset.value)
  return _internal_value();
}
inline void WalletAsset::_internal_set_value(double value) {
  
  value_ = value;
}
inline void WalletAsset::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:tradingpb.WalletAsset.value)
}

// -------------------------------------------------------------------

// Wallet

// repeated .tradingpb.WalletAsset assets = 1;
inline int Wallet::_internal_assets_size() const {
  return assets_.size();
}
inline int Wallet::assets_size() const {
  return _internal_assets_size();
}
inline void Wallet::clear_assets() {
  assets_.Clear();
}
inline ::tradingpb::WalletAsset* Wallet::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Wallet.assets)
  return assets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::WalletAsset >*
Wallet::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Wallet.assets)
  return &assets_;
}
inline const ::tradingpb::WalletAsset& Wallet::_internal_assets(int index) const {
  return assets_.Get(index);
}
inline const ::tradingpb::WalletAsset& Wallet::assets(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Wallet.assets)
  return _internal_assets(index);
}
inline ::tradingpb::WalletAsset* Wallet::_internal_add_assets() {
  return assets_.Add();
}
inline ::tradingpb::WalletAsset* Wallet::add_assets() {
  // @@protoc_insertion_point(field_add:tradingpb.Wallet.assets)
  return _internal_add_assets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::WalletAsset >&
Wallet::assets() const {
  // @@protoc_insertion_point(field_list:tradingpb.Wallet.assets)
  return assets_;
}

// -------------------------------------------------------------------

// CtrlCondition

// string indicator = 1 [deprecated = true];
inline void CtrlCondition::clear_indicator() {
  indicator_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CtrlCondition::indicator() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.indicator)
  return _internal_indicator();
}
inline void CtrlCondition::set_indicator(const std::string& value) {
  _internal_set_indicator(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.indicator)
}
inline std::string* CtrlCondition::mutable_indicator() {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlCondition.indicator)
  return _internal_mutable_indicator();
}
inline const std::string& CtrlCondition::_internal_indicator() const {
  return indicator_.GetNoArena();
}
inline void CtrlCondition::_internal_set_indicator(const std::string& value) {
  
  indicator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CtrlCondition::set_indicator(std::string&& value) {
  
  indicator_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.CtrlCondition.indicator)
}
inline void CtrlCondition::set_indicator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  indicator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.CtrlCondition.indicator)
}
inline void CtrlCondition::set_indicator(const char* value, size_t size) {
  
  indicator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.CtrlCondition.indicator)
}
inline std::string* CtrlCondition::_internal_mutable_indicator() {
  
  return indicator_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CtrlCondition::release_indicator() {
  // @@protoc_insertion_point(field_release:tradingpb.CtrlCondition.indicator)
  
  return indicator_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CtrlCondition::set_allocated_indicator(std::string* indicator) {
  if (indicator != nullptr) {
    
  } else {
    
  }
  indicator_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indicator);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.CtrlCondition.indicator)
}

// repeated float vals = 2;
inline int CtrlCondition::_internal_vals_size() const {
  return vals_.size();
}
inline int CtrlCondition::vals_size() const {
  return _internal_vals_size();
}
inline void CtrlCondition::clear_vals() {
  vals_.Clear();
}
inline float CtrlCondition::_internal_vals(int index) const {
  return vals_.Get(index);
}
inline float CtrlCondition::vals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.vals)
  return _internal_vals(index);
}
inline void CtrlCondition::set_vals(int index, float value) {
  vals_.Set(index, value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.vals)
}
inline void CtrlCondition::_internal_add_vals(float value) {
  vals_.Add(value);
}
inline void CtrlCondition::add_vals(float value) {
  _internal_add_vals(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.vals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::_internal_vals() const {
  return vals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::vals() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.vals)
  return _internal_vals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::_internal_mutable_vals() {
  return &vals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.vals)
  return _internal_mutable_vals();
}

// repeated string operators = 3;
inline int CtrlCondition::_internal_operators_size() const {
  return operators_.size();
}
inline int CtrlCondition::operators_size() const {
  return _internal_operators_size();
}
inline void CtrlCondition::clear_operators() {
  operators_.Clear();
}
inline std::string* CtrlCondition::add_operators() {
  // @@protoc_insertion_point(field_add_mutable:tradingpb.CtrlCondition.operators)
  return _internal_add_operators();
}
inline const std::string& CtrlCondition::_internal_operators(int index) const {
  return operators_.Get(index);
}
inline const std::string& CtrlCondition::operators(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.operators)
  return _internal_operators(index);
}
inline std::string* CtrlCondition::mutable_operators(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlCondition.operators)
  return operators_.Mutable(index);
}
inline void CtrlCondition::set_operators(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.operators)
  operators_.Mutable(index)->assign(value);
}
inline void CtrlCondition::set_operators(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.operators)
  operators_.Mutable(index)->assign(std::move(value));
}
inline void CtrlCondition::set_operators(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  operators_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tradingpb.CtrlCondition.operators)
}
inline void CtrlCondition::set_operators(int index, const char* value, size_t size) {
  operators_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tradingpb.CtrlCondition.operators)
}
inline std::string* CtrlCondition::_internal_add_operators() {
  return operators_.Add();
}
inline void CtrlCondition::add_operators(const std::string& value) {
  operators_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.operators)
}
inline void CtrlCondition::add_operators(std::string&& value) {
  operators_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.operators)
}
inline void CtrlCondition::add_operators(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  operators_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tradingpb.CtrlCondition.operators)
}
inline void CtrlCondition::add_operators(const char* value, size_t size) {
  operators_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tradingpb.CtrlCondition.operators)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CtrlCondition::operators() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.operators)
  return operators_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CtrlCondition::mutable_operators() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.operators)
  return &operators_;
}

// string combCondition = 4;
inline void CtrlCondition::clear_combcondition() {
  combcondition_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CtrlCondition::combcondition() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.combCondition)
  return _internal_combcondition();
}
inline void CtrlCondition::set_combcondition(const std::string& value) {
  _internal_set_combcondition(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.combCondition)
}
inline std::string* CtrlCondition::mutable_combcondition() {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlCondition.combCondition)
  return _internal_mutable_combcondition();
}
inline const std::string& CtrlCondition::_internal_combcondition() const {
  return combcondition_.GetNoArena();
}
inline void CtrlCondition::_internal_set_combcondition(const std::string& value) {
  
  combcondition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CtrlCondition::set_combcondition(std::string&& value) {
  
  combcondition_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.CtrlCondition.combCondition)
}
inline void CtrlCondition::set_combcondition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  combcondition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.CtrlCondition.combCondition)
}
inline void CtrlCondition::set_combcondition(const char* value, size_t size) {
  
  combcondition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.CtrlCondition.combCondition)
}
inline std::string* CtrlCondition::_internal_mutable_combcondition() {
  
  return combcondition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CtrlCondition::release_combcondition() {
  // @@protoc_insertion_point(field_release:tradingpb.CtrlCondition.combCondition)
  
  return combcondition_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CtrlCondition::set_allocated_combcondition(std::string* combcondition) {
  if (combcondition != nullptr) {
    
  } else {
    
  }
  combcondition_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), combcondition);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.CtrlCondition.combCondition)
}

// repeated float minvals = 5 [deprecated = true];
inline int CtrlCondition::_internal_minvals_size() const {
  return minvals_.size();
}
inline int CtrlCondition::minvals_size() const {
  return _internal_minvals_size();
}
inline void CtrlCondition::clear_minvals() {
  minvals_.Clear();
}
inline float CtrlCondition::_internal_minvals(int index) const {
  return minvals_.Get(index);
}
inline float CtrlCondition::minvals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.minvals)
  return _internal_minvals(index);
}
inline void CtrlCondition::set_minvals(int index, float value) {
  minvals_.Set(index, value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.minvals)
}
inline void CtrlCondition::_internal_add_minvals(float value) {
  minvals_.Add(value);
}
inline void CtrlCondition::add_minvals(float value) {
  _internal_add_minvals(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.minvals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::_internal_minvals() const {
  return minvals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::minvals() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.minvals)
  return _internal_minvals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::_internal_mutable_minvals() {
  return &minvals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::mutable_minvals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.minvals)
  return _internal_mutable_minvals();
}

// repeated float maxvals = 6 [deprecated = true];
inline int CtrlCondition::_internal_maxvals_size() const {
  return maxvals_.size();
}
inline int CtrlCondition::maxvals_size() const {
  return _internal_maxvals_size();
}
inline void CtrlCondition::clear_maxvals() {
  maxvals_.Clear();
}
inline float CtrlCondition::_internal_maxvals(int index) const {
  return maxvals_.Get(index);
}
inline float CtrlCondition::maxvals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.maxvals)
  return _internal_maxvals(index);
}
inline void CtrlCondition::set_maxvals(int index, float value) {
  maxvals_.Set(index, value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.maxvals)
}
inline void CtrlCondition::_internal_add_maxvals(float value) {
  maxvals_.Add(value);
}
inline void CtrlCondition::add_maxvals(float value) {
  _internal_add_maxvals(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.maxvals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::_internal_maxvals() const {
  return maxvals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::maxvals() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.maxvals)
  return _internal_maxvals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::_internal_mutable_maxvals() {
  return &maxvals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::mutable_maxvals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.maxvals)
  return _internal_mutable_maxvals();
}

// repeated float offvals = 7 [deprecated = true];
inline int CtrlCondition::_internal_offvals_size() const {
  return offvals_.size();
}
inline int CtrlCondition::offvals_size() const {
  return _internal_offvals_size();
}
inline void CtrlCondition::clear_offvals() {
  offvals_.Clear();
}
inline float CtrlCondition::_internal_offvals(int index) const {
  return offvals_.Get(index);
}
inline float CtrlCondition::offvals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.offvals)
  return _internal_offvals(index);
}
inline void CtrlCondition::set_offvals(int index, float value) {
  offvals_.Set(index, value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.offvals)
}
inline void CtrlCondition::_internal_add_offvals(float value) {
  offvals_.Add(value);
}
inline void CtrlCondition::add_offvals(float value) {
  _internal_add_offvals(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.offvals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::_internal_offvals() const {
  return offvals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::offvals() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.offvals)
  return _internal_offvals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::_internal_mutable_offvals() {
  return &offvals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::mutable_offvals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.offvals)
  return _internal_mutable_offvals();
}

// repeated string strVals = 8;
inline int CtrlCondition::_internal_strvals_size() const {
  return strvals_.size();
}
inline int CtrlCondition::strvals_size() const {
  return _internal_strvals_size();
}
inline void CtrlCondition::clear_strvals() {
  strvals_.Clear();
}
inline std::string* CtrlCondition::add_strvals() {
  // @@protoc_insertion_point(field_add_mutable:tradingpb.CtrlCondition.strVals)
  return _internal_add_strvals();
}
inline const std::string& CtrlCondition::_internal_strvals(int index) const {
  return strvals_.Get(index);
}
inline const std::string& CtrlCondition::strvals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.strVals)
  return _internal_strvals(index);
}
inline std::string* CtrlCondition::mutable_strvals(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlCondition.strVals)
  return strvals_.Mutable(index);
}
inline void CtrlCondition::set_strvals(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.strVals)
  strvals_.Mutable(index)->assign(value);
}
inline void CtrlCondition::set_strvals(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.strVals)
  strvals_.Mutable(index)->assign(std::move(value));
}
inline void CtrlCondition::set_strvals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  strvals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tradingpb.CtrlCondition.strVals)
}
inline void CtrlCondition::set_strvals(int index, const char* value, size_t size) {
  strvals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tradingpb.CtrlCondition.strVals)
}
inline std::string* CtrlCondition::_internal_add_strvals() {
  return strvals_.Add();
}
inline void CtrlCondition::add_strvals(const std::string& value) {
  strvals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.strVals)
}
inline void CtrlCondition::add_strvals(std::string&& value) {
  strvals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.strVals)
}
inline void CtrlCondition::add_strvals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  strvals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tradingpb.CtrlCondition.strVals)
}
inline void CtrlCondition::add_strvals(const char* value, size_t size) {
  strvals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tradingpb.CtrlCondition.strVals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CtrlCondition::strvals() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.strVals)
  return strvals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CtrlCondition::mutable_strvals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.strVals)
  return &strvals_;
}

// string name = 9;
inline void CtrlCondition::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CtrlCondition::name() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.name)
  return _internal_name();
}
inline void CtrlCondition::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.name)
}
inline std::string* CtrlCondition::mutable_name() {
  // @@protoc_insertion_point(field_mutable:tradingpb.CtrlCondition.name)
  return _internal_mutable_name();
}
inline const std::string& CtrlCondition::_internal_name() const {
  return name_.GetNoArena();
}
inline void CtrlCondition::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CtrlCondition::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.CtrlCondition.name)
}
inline void CtrlCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.CtrlCondition.name)
}
inline void CtrlCondition::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.CtrlCondition.name)
}
inline std::string* CtrlCondition::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CtrlCondition::release_name() {
  // @@protoc_insertion_point(field_release:tradingpb.CtrlCondition.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CtrlCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.CtrlCondition.name)
}

// int32 group = 10;
inline void CtrlCondition::clear_group() {
  group_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlCondition::_internal_group() const {
  return group_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CtrlCondition::group() const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.group)
  return _internal_group();
}
inline void CtrlCondition::_internal_set_group(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  group_ = value;
}
inline void CtrlCondition::set_group(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.group)
}

// repeated float int64Vals = 11;
inline int CtrlCondition::_internal_int64vals_size() const {
  return int64vals_.size();
}
inline int CtrlCondition::int64vals_size() const {
  return _internal_int64vals_size();
}
inline void CtrlCondition::clear_int64vals() {
  int64vals_.Clear();
}
inline float CtrlCondition::_internal_int64vals(int index) const {
  return int64vals_.Get(index);
}
inline float CtrlCondition::int64vals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.CtrlCondition.int64Vals)
  return _internal_int64vals(index);
}
inline void CtrlCondition::set_int64vals(int index, float value) {
  int64vals_.Set(index, value);
  // @@protoc_insertion_point(field_set:tradingpb.CtrlCondition.int64Vals)
}
inline void CtrlCondition::_internal_add_int64vals(float value) {
  int64vals_.Add(value);
}
inline void CtrlCondition::add_int64vals(float value) {
  _internal_add_int64vals(value);
  // @@protoc_insertion_point(field_add:tradingpb.CtrlCondition.int64Vals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::_internal_int64vals() const {
  return int64vals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CtrlCondition::int64vals() const {
  // @@protoc_insertion_point(field_list:tradingpb.CtrlCondition.int64Vals)
  return _internal_int64vals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::_internal_mutable_int64vals() {
  return &int64vals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CtrlCondition::mutable_int64vals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.CtrlCondition.int64Vals)
  return _internal_mutable_int64vals();
}

// -------------------------------------------------------------------

// IndicatorData

// repeated float vals = 1;
inline int IndicatorData::_internal_vals_size() const {
  return vals_.size();
}
inline int IndicatorData::vals_size() const {
  return _internal_vals_size();
}
inline void IndicatorData::clear_vals() {
  vals_.Clear();
}
inline float IndicatorData::_internal_vals(int index) const {
  return vals_.Get(index);
}
inline float IndicatorData::vals(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.IndicatorData.vals)
  return _internal_vals(index);
}
inline void IndicatorData::set_vals(int index, float value) {
  vals_.Set(index, value);
  // @@protoc_insertion_point(field_set:tradingpb.IndicatorData.vals)
}
inline void IndicatorData::_internal_add_vals(float value) {
  vals_.Add(value);
}
inline void IndicatorData::add_vals(float value) {
  _internal_add_vals(value);
  // @@protoc_insertion_point(field_add:tradingpb.IndicatorData.vals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
IndicatorData::_internal_vals() const {
  return vals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
IndicatorData::vals() const {
  // @@protoc_insertion_point(field_list:tradingpb.IndicatorData.vals)
  return _internal_vals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
IndicatorData::_internal_mutable_vals() {
  return &vals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
IndicatorData::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.IndicatorData.vals)
  return _internal_mutable_vals();
}

// int64 ts = 2;
inline void IndicatorData::clear_ts() {
  ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndicatorData::_internal_ts() const {
  return ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndicatorData::ts() const {
  // @@protoc_insertion_point(field_get:tradingpb.IndicatorData.ts)
  return _internal_ts();
}
inline void IndicatorData::_internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ts_ = value;
}
inline void IndicatorData::set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:tradingpb.IndicatorData.ts)
}

// -------------------------------------------------------------------

// Indicator

// string fullname = 1;
inline void Indicator::clear_fullname() {
  fullname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Indicator::fullname() const {
  // @@protoc_insertion_point(field_get:tradingpb.Indicator.fullname)
  return _internal_fullname();
}
inline void Indicator::set_fullname(const std::string& value) {
  _internal_set_fullname(value);
  // @@protoc_insertion_point(field_set:tradingpb.Indicator.fullname)
}
inline std::string* Indicator::mutable_fullname() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Indicator.fullname)
  return _internal_mutable_fullname();
}
inline const std::string& Indicator::_internal_fullname() const {
  return fullname_.GetNoArena();
}
inline void Indicator::_internal_set_fullname(const std::string& value) {
  
  fullname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Indicator::set_fullname(std::string&& value) {
  
  fullname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.Indicator.fullname)
}
inline void Indicator::set_fullname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fullname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.Indicator.fullname)
}
inline void Indicator::set_fullname(const char* value, size_t size) {
  
  fullname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Indicator.fullname)
}
inline std::string* Indicator::_internal_mutable_fullname() {
  
  return fullname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Indicator::release_fullname() {
  // @@protoc_insertion_point(field_release:tradingpb.Indicator.fullname)
  
  return fullname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Indicator::set_allocated_fullname(std::string* fullname) {
  if (fullname != nullptr) {
    
  } else {
    
  }
  fullname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullname);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Indicator.fullname)
}

// .tradingpb.IndicatorType type = 2;
inline void Indicator::clear_type() {
  type_ = 0;
}
inline ::tradingpb::IndicatorType Indicator::_internal_type() const {
  return static_cast< ::tradingpb::IndicatorType >(type_);
}
inline ::tradingpb::IndicatorType Indicator::type() const {
  // @@protoc_insertion_point(field_get:tradingpb.Indicator.type)
  return _internal_type();
}
inline void Indicator::_internal_set_type(::tradingpb::IndicatorType value) {
  
  type_ = value;
}
inline void Indicator::set_type(::tradingpb::IndicatorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tradingpb.Indicator.type)
}

// repeated .tradingpb.IndicatorData data = 3;
inline int Indicator::_internal_data_size() const {
  return data_.size();
}
inline int Indicator::data_size() const {
  return _internal_data_size();
}
inline void Indicator::clear_data() {
  data_.Clear();
}
inline ::tradingpb::IndicatorData* Indicator::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Indicator.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::IndicatorData >*
Indicator::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Indicator.data)
  return &data_;
}
inline const ::tradingpb::IndicatorData& Indicator::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::tradingpb::IndicatorData& Indicator::data(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Indicator.data)
  return _internal_data(index);
}
inline ::tradingpb::IndicatorData* Indicator::_internal_add_data() {
  return data_.Add();
}
inline ::tradingpb::IndicatorData* Indicator::add_data() {
  // @@protoc_insertion_point(field_add:tradingpb.Indicator.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::IndicatorData >&
Indicator::data() const {
  // @@protoc_insertion_point(field_list:tradingpb.Indicator.data)
  return data_;
}

// -------------------------------------------------------------------

// BuyParams

// float initMoney = 1 [deprecated = true];
inline void BuyParams::clear_initmoney() {
  initmoney_ = 0;
}
inline float BuyParams::_internal_initmoney() const {
  return initmoney_;
}
inline float BuyParams::initmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.initMoney)
  return _internal_initmoney();
}
inline void BuyParams::_internal_set_initmoney(float value) {
  
  initmoney_ = value;
}
inline void BuyParams::set_initmoney(float value) {
  _internal_set_initmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.initMoney)
}

// float perMoney = 2 [deprecated = true];
inline void BuyParams::clear_permoney() {
  permoney_ = 0;
}
inline float BuyParams::_internal_permoney() const {
  return permoney_;
}
inline float BuyParams::permoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.perMoney)
  return _internal_permoney();
}
inline void BuyParams::_internal_set_permoney(float value) {
  
  permoney_ = value;
}
inline void BuyParams::set_permoney(float value) {
  _internal_set_permoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.perMoney)
}

// float volume = 3;
inline void BuyParams::clear_volume() {
  volume_ = 0;
}
inline float BuyParams::_internal_volume() const {
  return volume_;
}
inline float BuyParams::volume() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.volume)
  return _internal_volume();
}
inline void BuyParams::_internal_set_volume(float value) {
  
  volume_ = value;
}
inline void BuyParams::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.volume)
}

// float aipMoney = 4;
inline void BuyParams::clear_aipmoney() {
  aipmoney_ = 0;
}
inline float BuyParams::_internal_aipmoney() const {
  return aipmoney_;
}
inline float BuyParams::aipmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.aipMoney)
  return _internal_aipmoney();
}
inline void BuyParams::_internal_set_aipmoney(float value) {
  
  aipmoney_ = value;
}
inline void BuyParams::set_aipmoney(float value) {
  _internal_set_aipmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.aipMoney)
}

// float perInitMoney = 5;
inline void BuyParams::clear_perinitmoney() {
  perinitmoney_ = 0;
}
inline float BuyParams::_internal_perinitmoney() const {
  return perinitmoney_;
}
inline float BuyParams::perinitmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.perInitMoney)
  return _internal_perinitmoney();
}
inline void BuyParams::_internal_set_perinitmoney(float value) {
  
  perinitmoney_ = value;
}
inline void BuyParams::set_perinitmoney(float value) {
  _internal_set_perinitmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.perInitMoney)
}

// float perHandMoney = 6;
inline void BuyParams::clear_perhandmoney() {
  perhandmoney_ = 0;
}
inline float BuyParams::_internal_perhandmoney() const {
  return perhandmoney_;
}
inline float BuyParams::perhandmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.perHandMoney)
  return _internal_perhandmoney();
}
inline void BuyParams::_internal_set_perhandmoney(float value) {
  
  perhandmoney_ = value;
}
inline void BuyParams::set_perhandmoney(float value) {
  _internal_set_perhandmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.perHandMoney)
}

// float perTotalMoney = 7 [deprecated = true];
inline void BuyParams::clear_pertotalmoney() {
  pertotalmoney_ = 0;
}
inline float BuyParams::_internal_pertotalmoney() const {
  return pertotalmoney_;
}
inline float BuyParams::pertotalmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.perTotalMoney)
  return _internal_pertotalmoney();
}
inline void BuyParams::_internal_set_pertotalmoney(float value) {
  
  pertotalmoney_ = value;
}
inline void BuyParams::set_pertotalmoney(float value) {
  _internal_set_pertotalmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.perTotalMoney)
}

// string assetCode = 8;
inline void BuyParams::clear_assetcode() {
  assetcode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuyParams::assetcode() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.assetCode)
  return _internal_assetcode();
}
inline void BuyParams::set_assetcode(const std::string& value) {
  _internal_set_assetcode(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.assetCode)
}
inline std::string* BuyParams::mutable_assetcode() {
  // @@protoc_insertion_point(field_mutable:tradingpb.BuyParams.assetCode)
  return _internal_mutable_assetcode();
}
inline const std::string& BuyParams::_internal_assetcode() const {
  return assetcode_.GetNoArena();
}
inline void BuyParams::_internal_set_assetcode(const std::string& value) {
  
  assetcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuyParams::set_assetcode(std::string&& value) {
  
  assetcode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.BuyParams.assetCode)
}
inline void BuyParams::set_assetcode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  assetcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.BuyParams.assetCode)
}
inline void BuyParams::set_assetcode(const char* value, size_t size) {
  
  assetcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.BuyParams.assetCode)
}
inline std::string* BuyParams::_internal_mutable_assetcode() {
  
  return assetcode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuyParams::release_assetcode() {
  // @@protoc_insertion_point(field_release:tradingpb.BuyParams.assetCode)
  
  return assetcode_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuyParams::set_allocated_assetcode(std::string* assetcode) {
  if (assetcode != nullptr) {
    
  } else {
    
  }
  assetcode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assetcode);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.BuyParams.assetCode)
}

// string timeTypeBuyAsset = 9;
inline void BuyParams::clear_timetypebuyasset() {
  timetypebuyasset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuyParams::timetypebuyasset() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.timeTypeBuyAsset)
  return _internal_timetypebuyasset();
}
inline void BuyParams::set_timetypebuyasset(const std::string& value) {
  _internal_set_timetypebuyasset(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.timeTypeBuyAsset)
}
inline std::string* BuyParams::mutable_timetypebuyasset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.BuyParams.timeTypeBuyAsset)
  return _internal_mutable_timetypebuyasset();
}
inline const std::string& BuyParams::_internal_timetypebuyasset() const {
  return timetypebuyasset_.GetNoArena();
}
inline void BuyParams::_internal_set_timetypebuyasset(const std::string& value) {
  
  timetypebuyasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuyParams::set_timetypebuyasset(std::string&& value) {
  
  timetypebuyasset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.BuyParams.timeTypeBuyAsset)
}
inline void BuyParams::set_timetypebuyasset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timetypebuyasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.BuyParams.timeTypeBuyAsset)
}
inline void BuyParams::set_timetypebuyasset(const char* value, size_t size) {
  
  timetypebuyasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.BuyParams.timeTypeBuyAsset)
}
inline std::string* BuyParams::_internal_mutable_timetypebuyasset() {
  
  return timetypebuyasset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuyParams::release_timetypebuyasset() {
  // @@protoc_insertion_point(field_release:tradingpb.BuyParams.timeTypeBuyAsset)
  
  return timetypebuyasset_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuyParams::set_allocated_timetypebuyasset(std::string* timetypebuyasset) {
  if (timetypebuyasset != nullptr) {
    
  } else {
    
  }
  timetypebuyasset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timetypebuyasset);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.BuyParams.timeTypeBuyAsset)
}

// int64 tsOffBuy = 10;
inline void BuyParams::clear_tsoffbuy() {
  tsoffbuy_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BuyParams::_internal_tsoffbuy() const {
  return tsoffbuy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BuyParams::tsoffbuy() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.tsOffBuy)
  return _internal_tsoffbuy();
}
inline void BuyParams::_internal_set_tsoffbuy(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tsoffbuy_ = value;
}
inline void BuyParams::set_tsoffbuy(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tsoffbuy(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.tsOffBuy)
}

// string typeBuyAsset = 11;
inline void BuyParams::clear_typebuyasset() {
  typebuyasset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuyParams::typebuyasset() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.typeBuyAsset)
  return _internal_typebuyasset();
}
inline void BuyParams::set_typebuyasset(const std::string& value) {
  _internal_set_typebuyasset(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.typeBuyAsset)
}
inline std::string* BuyParams::mutable_typebuyasset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.BuyParams.typeBuyAsset)
  return _internal_mutable_typebuyasset();
}
inline const std::string& BuyParams::_internal_typebuyasset() const {
  return typebuyasset_.GetNoArena();
}
inline void BuyParams::_internal_set_typebuyasset(const std::string& value) {
  
  typebuyasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuyParams::set_typebuyasset(std::string&& value) {
  
  typebuyasset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.BuyParams.typeBuyAsset)
}
inline void BuyParams::set_typebuyasset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  typebuyasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.BuyParams.typeBuyAsset)
}
inline void BuyParams::set_typebuyasset(const char* value, size_t size) {
  
  typebuyasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.BuyParams.typeBuyAsset)
}
inline std::string* BuyParams::_internal_mutable_typebuyasset() {
  
  return typebuyasset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuyParams::release_typebuyasset() {
  // @@protoc_insertion_point(field_release:tradingpb.BuyParams.typeBuyAsset)
  
  return typebuyasset_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuyParams::set_allocated_typebuyasset(std::string* typebuyasset) {
  if (typebuyasset != nullptr) {
    
  } else {
    
  }
  typebuyasset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), typebuyasset);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.BuyParams.typeBuyAsset)
}

// int32 moneyParts = 12;
inline void BuyParams::clear_moneyparts() {
  moneyparts_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuyParams::_internal_moneyparts() const {
  return moneyparts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuyParams::moneyparts() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.moneyParts)
  return _internal_moneyparts();
}
inline void BuyParams::_internal_set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  moneyparts_ = value;
}
inline void BuyParams::set_moneyparts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_moneyparts(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.moneyParts)
}

// int32 nextTimes = 13;
inline void BuyParams::clear_nexttimes() {
  nexttimes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuyParams::_internal_nexttimes() const {
  return nexttimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuyParams::nexttimes() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.nextTimes)
  return _internal_nexttimes();
}
inline void BuyParams::_internal_set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nexttimes_ = value;
}
inline void BuyParams::set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nexttimes(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.nextTimes)
}

// int32 depositMoney = 14;
inline void BuyParams::clear_depositmoney() {
  depositmoney_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuyParams::_internal_depositmoney() const {
  return depositmoney_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuyParams::depositmoney() const {
  // @@protoc_insertion_point(field_get:tradingpb.BuyParams.depositMoney)
  return _internal_depositmoney();
}
inline void BuyParams::_internal_set_depositmoney(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  depositmoney_ = value;
}
inline void BuyParams::set_depositmoney(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depositmoney(value);
  // @@protoc_insertion_point(field_set:tradingpb.BuyParams.depositMoney)
}

// -------------------------------------------------------------------

// SellParams

// float volume = 1;
inline void SellParams::clear_volume() {
  volume_ = 0;
}
inline float SellParams::_internal_volume() const {
  return volume_;
}
inline float SellParams::volume() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.volume)
  return _internal_volume();
}
inline void SellParams::_internal_set_volume(float value) {
  
  volume_ = value;
}
inline void SellParams::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.volume)
}

// float perVolume = 2;
inline void SellParams::clear_pervolume() {
  pervolume_ = 0;
}
inline float SellParams::_internal_pervolume() const {
  return pervolume_;
}
inline float SellParams::pervolume() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.perVolume)
  return _internal_pervolume();
}
inline void SellParams::_internal_set_pervolume(float value) {
  
  pervolume_ = value;
}
inline void SellParams::set_pervolume(float value) {
  _internal_set_pervolume(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.perVolume)
}

// float money = 3;
inline void SellParams::clear_money() {
  money_ = 0;
}
inline float SellParams::_internal_money() const {
  return money_;
}
inline float SellParams::money() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.money)
  return _internal_money();
}
inline void SellParams::_internal_set_money(float value) {
  
  money_ = value;
}
inline void SellParams::set_money(float value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.money)
}

// int64 keepTime = 4;
inline void SellParams::clear_keeptime() {
  keeptime_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SellParams::_internal_keeptime() const {
  return keeptime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SellParams::keeptime() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.keepTime)
  return _internal_keeptime();
}
inline void SellParams::_internal_set_keeptime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  keeptime_ = value;
}
inline void SellParams::set_keeptime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_keeptime(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.keepTime)
}

// string assetCode = 5;
inline void SellParams::clear_assetcode() {
  assetcode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SellParams::assetcode() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.assetCode)
  return _internal_assetcode();
}
inline void SellParams::set_assetcode(const std::string& value) {
  _internal_set_assetcode(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.assetCode)
}
inline std::string* SellParams::mutable_assetcode() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SellParams.assetCode)
  return _internal_mutable_assetcode();
}
inline const std::string& SellParams::_internal_assetcode() const {
  return assetcode_.GetNoArena();
}
inline void SellParams::_internal_set_assetcode(const std::string& value) {
  
  assetcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SellParams::set_assetcode(std::string&& value) {
  
  assetcode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SellParams.assetCode)
}
inline void SellParams::set_assetcode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  assetcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SellParams.assetCode)
}
inline void SellParams::set_assetcode(const char* value, size_t size) {
  
  assetcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SellParams.assetCode)
}
inline std::string* SellParams::_internal_mutable_assetcode() {
  
  return assetcode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SellParams::release_assetcode() {
  // @@protoc_insertion_point(field_release:tradingpb.SellParams.assetCode)
  
  return assetcode_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SellParams::set_allocated_assetcode(std::string* assetcode) {
  if (assetcode != nullptr) {
    
  } else {
    
  }
  assetcode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assetcode);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SellParams.assetCode)
}

// string timeTypeSellAsset = 6;
inline void SellParams::clear_timetypesellasset() {
  timetypesellasset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SellParams::timetypesellasset() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.timeTypeSellAsset)
  return _internal_timetypesellasset();
}
inline void SellParams::set_timetypesellasset(const std::string& value) {
  _internal_set_timetypesellasset(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.timeTypeSellAsset)
}
inline std::string* SellParams::mutable_timetypesellasset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SellParams.timeTypeSellAsset)
  return _internal_mutable_timetypesellasset();
}
inline const std::string& SellParams::_internal_timetypesellasset() const {
  return timetypesellasset_.GetNoArena();
}
inline void SellParams::_internal_set_timetypesellasset(const std::string& value) {
  
  timetypesellasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SellParams::set_timetypesellasset(std::string&& value) {
  
  timetypesellasset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SellParams.timeTypeSellAsset)
}
inline void SellParams::set_timetypesellasset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timetypesellasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SellParams.timeTypeSellAsset)
}
inline void SellParams::set_timetypesellasset(const char* value, size_t size) {
  
  timetypesellasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SellParams.timeTypeSellAsset)
}
inline std::string* SellParams::_internal_mutable_timetypesellasset() {
  
  return timetypesellasset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SellParams::release_timetypesellasset() {
  // @@protoc_insertion_point(field_release:tradingpb.SellParams.timeTypeSellAsset)
  
  return timetypesellasset_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SellParams::set_allocated_timetypesellasset(std::string* timetypesellasset) {
  if (timetypesellasset != nullptr) {
    
  } else {
    
  }
  timetypesellasset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timetypesellasset);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SellParams.timeTypeSellAsset)
}

// int64 tsOffSell = 7;
inline void SellParams::clear_tsoffsell() {
  tsoffsell_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SellParams::_internal_tsoffsell() const {
  return tsoffsell_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SellParams::tsoffsell() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.tsOffSell)
  return _internal_tsoffsell();
}
inline void SellParams::_internal_set_tsoffsell(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tsoffsell_ = value;
}
inline void SellParams::set_tsoffsell(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tsoffsell(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.tsOffSell)
}

// string typeSellAsset = 8;
inline void SellParams::clear_typesellasset() {
  typesellasset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SellParams::typesellasset() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.typeSellAsset)
  return _internal_typesellasset();
}
inline void SellParams::set_typesellasset(const std::string& value) {
  _internal_set_typesellasset(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.typeSellAsset)
}
inline std::string* SellParams::mutable_typesellasset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SellParams.typeSellAsset)
  return _internal_mutable_typesellasset();
}
inline const std::string& SellParams::_internal_typesellasset() const {
  return typesellasset_.GetNoArena();
}
inline void SellParams::_internal_set_typesellasset(const std::string& value) {
  
  typesellasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SellParams::set_typesellasset(std::string&& value) {
  
  typesellasset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SellParams.typeSellAsset)
}
inline void SellParams::set_typesellasset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  typesellasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SellParams.typeSellAsset)
}
inline void SellParams::set_typesellasset(const char* value, size_t size) {
  
  typesellasset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SellParams.typeSellAsset)
}
inline std::string* SellParams::_internal_mutable_typesellasset() {
  
  return typesellasset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SellParams::release_typesellasset() {
  // @@protoc_insertion_point(field_release:tradingpb.SellParams.typeSellAsset)
  
  return typesellasset_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SellParams::set_allocated_typesellasset(std::string* typesellasset) {
  if (typesellasset != nullptr) {
    
  } else {
    
  }
  typesellasset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), typesellasset);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SellParams.typeSellAsset)
}

// int32 nextTimes = 9;
inline void SellParams::clear_nexttimes() {
  nexttimes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SellParams::_internal_nexttimes() const {
  return nexttimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SellParams::nexttimes() const {
  // @@protoc_insertion_point(field_get:tradingpb.SellParams.nextTimes)
  return _internal_nexttimes();
}
inline void SellParams::_internal_set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nexttimes_ = value;
}
inline void SellParams::set_nexttimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nexttimes(value);
  // @@protoc_insertion_point(field_set:tradingpb.SellParams.nextTimes)
}

// -------------------------------------------------------------------

// StopLossParams

// float drawdown = 1 [deprecated = true];
inline void StopLossParams::clear_drawdown() {
  drawdown_ = 0;
}
inline float StopLossParams::_internal_drawdown() const {
  return drawdown_;
}
inline float StopLossParams::drawdown() const {
  // @@protoc_insertion_point(field_get:tradingpb.StopLossParams.drawdown)
  return _internal_drawdown();
}
inline void StopLossParams::_internal_set_drawdown(float value) {
  
  drawdown_ = value;
}
inline void StopLossParams::set_drawdown(float value) {
  _internal_set_drawdown(value);
  // @@protoc_insertion_point(field_set:tradingpb.StopLossParams.drawdown)
}

// bool isFinish = 2;
inline void StopLossParams::clear_isfinish() {
  isfinish_ = false;
}
inline bool StopLossParams::_internal_isfinish() const {
  return isfinish_;
}
inline bool StopLossParams::isfinish() const {
  // @@protoc_insertion_point(field_get:tradingpb.StopLossParams.isFinish)
  return _internal_isfinish();
}
inline void StopLossParams::_internal_set_isfinish(bool value) {
  
  isfinish_ = value;
}
inline void StopLossParams::set_isfinish(bool value) {
  _internal_set_isfinish(value);
  // @@protoc_insertion_point(field_set:tradingpb.StopLossParams.isFinish)
}

// float perVolume = 3;
inline void StopLossParams::clear_pervolume() {
  pervolume_ = 0;
}
inline float StopLossParams::_internal_pervolume() const {
  return pervolume_;
}
inline float StopLossParams::pervolume() const {
  // @@protoc_insertion_point(field_get:tradingpb.StopLossParams.perVolume)
  return _internal_pervolume();
}
inline void StopLossParams::_internal_set_pervolume(float value) {
  
  pervolume_ = value;
}
inline void StopLossParams::set_pervolume(float value) {
  _internal_set_pervolume(value);
  // @@protoc_insertion_point(field_set:tradingpb.StopLossParams.perVolume)
}

// -------------------------------------------------------------------

// TakeProfitParams

// float profit = 1 [deprecated = true];
inline void TakeProfitParams::clear_profit() {
  profit_ = 0;
}
inline float TakeProfitParams::_internal_profit() const {
  return profit_;
}
inline float TakeProfitParams::profit() const {
  // @@protoc_insertion_point(field_get:tradingpb.TakeProfitParams.profit)
  return _internal_profit();
}
inline void TakeProfitParams::_internal_set_profit(float value) {
  
  profit_ = value;
}
inline void TakeProfitParams::set_profit(float value) {
  _internal_set_profit(value);
  // @@protoc_insertion_point(field_set:tradingpb.TakeProfitParams.profit)
}

// bool isFinish = 2;
inline void TakeProfitParams::clear_isfinish() {
  isfinish_ = false;
}
inline bool TakeProfitParams::_internal_isfinish() const {
  return isfinish_;
}
inline bool TakeProfitParams::isfinish() const {
  // @@protoc_insertion_point(field_get:tradingpb.TakeProfitParams.isFinish)
  return _internal_isfinish();
}
inline void TakeProfitParams::_internal_set_isfinish(bool value) {
  
  isfinish_ = value;
}
inline void TakeProfitParams::set_isfinish(bool value) {
  _internal_set_isfinish(value);
  // @@protoc_insertion_point(field_set:tradingpb.TakeProfitParams.isFinish)
}

// float perVolume = 3;
inline void TakeProfitParams::clear_pervolume() {
  pervolume_ = 0;
}
inline float TakeProfitParams::_internal_pervolume() const {
  return pervolume_;
}
inline float TakeProfitParams::pervolume() const {
  // @@protoc_insertion_point(field_get:tradingpb.TakeProfitParams.perVolume)
  return _internal_pervolume();
}
inline void TakeProfitParams::_internal_set_pervolume(float value) {
  
  pervolume_ = value;
}
inline void TakeProfitParams::set_pervolume(float value) {
  _internal_set_pervolume(value);
  // @@protoc_insertion_point(field_set:tradingpb.TakeProfitParams.perVolume)
}

// string giveTo = 4;
inline void TakeProfitParams::clear_giveto() {
  giveto_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TakeProfitParams::giveto() const {
  // @@protoc_insertion_point(field_get:tradingpb.TakeProfitParams.giveTo)
  return _internal_giveto();
}
inline void TakeProfitParams::set_giveto(const std::string& value) {
  _internal_set_giveto(value);
  // @@protoc_insertion_point(field_set:tradingpb.TakeProfitParams.giveTo)
}
inline std::string* TakeProfitParams::mutable_giveto() {
  // @@protoc_insertion_point(field_mutable:tradingpb.TakeProfitParams.giveTo)
  return _internal_mutable_giveto();
}
inline const std::string& TakeProfitParams::_internal_giveto() const {
  return giveto_.GetNoArena();
}
inline void TakeProfitParams::_internal_set_giveto(const std::string& value) {
  
  giveto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TakeProfitParams::set_giveto(std::string&& value) {
  
  giveto_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.TakeProfitParams.giveTo)
}
inline void TakeProfitParams::set_giveto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  giveto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.TakeProfitParams.giveTo)
}
inline void TakeProfitParams::set_giveto(const char* value, size_t size) {
  
  giveto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.TakeProfitParams.giveTo)
}
inline std::string* TakeProfitParams::_internal_mutable_giveto() {
  
  return giveto_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TakeProfitParams::release_giveto() {
  // @@protoc_insertion_point(field_release:tradingpb.TakeProfitParams.giveTo)
  
  return giveto_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TakeProfitParams::set_allocated_giveto(std::string* giveto) {
  if (giveto != nullptr) {
    
  } else {
    
  }
  giveto_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), giveto);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.TakeProfitParams.giveTo)
}

// bool isOnlyProfit = 5;
inline void TakeProfitParams::clear_isonlyprofit() {
  isonlyprofit_ = false;
}
inline bool TakeProfitParams::_internal_isonlyprofit() const {
  return isonlyprofit_;
}
inline bool TakeProfitParams::isonlyprofit() const {
  // @@protoc_insertion_point(field_get:tradingpb.TakeProfitParams.isOnlyProfit)
  return _internal_isonlyprofit();
}
inline void TakeProfitParams::_internal_set_isonlyprofit(bool value) {
  
  isonlyprofit_ = value;
}
inline void TakeProfitParams::set_isonlyprofit(bool value) {
  _internal_set_isonlyprofit(value);
  // @@protoc_insertion_point(field_set:tradingpb.TakeProfitParams.isOnlyProfit)
}

// -------------------------------------------------------------------

// InitParams

// float money = 1;
inline void InitParams::clear_money() {
  money_ = 0;
}
inline float InitParams::_internal_money() const {
  return money_;
}
inline float InitParams::money() const {
  // @@protoc_insertion_point(field_get:tradingpb.InitParams.money)
  return _internal_money();
}
inline void InitParams::_internal_set_money(float value) {
  
  money_ = value;
}
inline void InitParams::set_money(float value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:tradingpb.InitParams.money)
}

// float vomume = 2;
inline void InitParams::clear_vomume() {
  vomume_ = 0;
}
inline float InitParams::_internal_vomume() const {
  return vomume_;
}
inline float InitParams::vomume() const {
  // @@protoc_insertion_point(field_get:tradingpb.InitParams.vomume)
  return _internal_vomume();
}
inline void InitParams::_internal_set_vomume(float value) {
  
  vomume_ = value;
}
inline void InitParams::set_vomume(float value) {
  _internal_set_vomume(value);
  // @@protoc_insertion_point(field_set:tradingpb.InitParams.vomume)
}

// -------------------------------------------------------------------

// AIPParams

// float money = 1;
inline void AIPParams::clear_money() {
  money_ = 0;
}
inline float AIPParams::_internal_money() const {
  return money_;
}
inline float AIPParams::money() const {
  // @@protoc_insertion_point(field_get:tradingpb.AIPParams.money)
  return _internal_money();
}
inline void AIPParams::_internal_set_money(float value) {
  
  money_ = value;
}
inline void AIPParams::set_money(float value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:tradingpb.AIPParams.money)
}

// .tradingpb.AIPTimeType type = 2;
inline void AIPParams::clear_type() {
  type_ = 0;
}
inline ::tradingpb::AIPTimeType AIPParams::_internal_type() const {
  return static_cast< ::tradingpb::AIPTimeType >(type_);
}
inline ::tradingpb::AIPTimeType AIPParams::type() const {
  // @@protoc_insertion_point(field_get:tradingpb.AIPParams.type)
  return _internal_type();
}
inline void AIPParams::_internal_set_type(::tradingpb::AIPTimeType value) {
  
  type_ = value;
}
inline void AIPParams::set_type(::tradingpb::AIPTimeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tradingpb.AIPParams.type)
}

// int32 day = 3;
inline void AIPParams::clear_day() {
  day_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AIPParams::_internal_day() const {
  return day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AIPParams::day() const {
  // @@protoc_insertion_point(field_get:tradingpb.AIPParams.day)
  return _internal_day();
}
inline void AIPParams::_internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  day_ = value;
}
inline void AIPParams::set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:tradingpb.AIPParams.day)
}

// -------------------------------------------------------------------

// FeeParams

// float percentage = 1;
inline void FeeParams::clear_percentage() {
  percentage_ = 0;
}
inline float FeeParams::_internal_percentage() const {
  return percentage_;
}
inline float FeeParams::percentage() const {
  // @@protoc_insertion_point(field_get:tradingpb.FeeParams.percentage)
  return _internal_percentage();
}
inline void FeeParams::_internal_set_percentage(float value) {
  
  percentage_ = value;
}
inline void FeeParams::set_percentage(float value) {
  _internal_set_percentage(value);
  // @@protoc_insertion_point(field_set:tradingpb.FeeParams.percentage)
}

// float minLimit = 2;
inline void FeeParams::clear_minlimit() {
  minlimit_ = 0;
}
inline float FeeParams::_internal_minlimit() const {
  return minlimit_;
}
inline float FeeParams::minlimit() const {
  // @@protoc_insertion_point(field_get:tradingpb.FeeParams.minLimit)
  return _internal_minlimit();
}
inline void FeeParams::_internal_set_minlimit(float value) {
  
  minlimit_ = value;
}
inline void FeeParams::set_minlimit(float value) {
  _internal_set_minlimit(value);
  // @@protoc_insertion_point(field_set:tradingpb.FeeParams.minLimit)
}

// float maxLimit = 3;
inline void FeeParams::clear_maxlimit() {
  maxlimit_ = 0;
}
inline float FeeParams::_internal_maxlimit() const {
  return maxlimit_;
}
inline float FeeParams::maxlimit() const {
  // @@protoc_insertion_point(field_get:tradingpb.FeeParams.maxLimit)
  return _internal_maxlimit();
}
inline void FeeParams::_internal_set_maxlimit(float value) {
  
  maxlimit_ = value;
}
inline void FeeParams::set_maxlimit(float value) {
  _internal_set_maxlimit(value);
  // @@protoc_insertion_point(field_set:tradingpb.FeeParams.maxLimit)
}

// -------------------------------------------------------------------

// Strategy

// string name = 1;
inline void Strategy::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Strategy::name() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.name)
  return _internal_name();
}
inline void Strategy::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:tradingpb.Strategy.name)
}
inline std::string* Strategy::mutable_name() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.name)
  return _internal_mutable_name();
}
inline const std::string& Strategy::_internal_name() const {
  return name_.GetNoArena();
}
inline void Strategy::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Strategy::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.Strategy.name)
}
inline void Strategy::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.Strategy.name)
}
inline void Strategy::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Strategy.name)
}
inline std::string* Strategy::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Strategy::release_name() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Strategy::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.name)
}

// .tradingpb.Asset asset = 2;
inline bool Strategy::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool Strategy::has_asset() const {
  return _internal_has_asset();
}
inline void Strategy::clear_asset() {
  if (GetArenaNoVirtual() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::tradingpb::Asset& Strategy::_internal_asset() const {
  const ::tradingpb::Asset* p = asset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::Asset*>(
      &::tradingpb::_Asset_default_instance_);
}
inline const ::tradingpb::Asset& Strategy::asset() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.asset)
  return _internal_asset();
}
inline ::tradingpb::Asset* Strategy::release_asset() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.asset)
  
  ::tradingpb::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::tradingpb::Asset* Strategy::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::Asset>(GetArenaNoVirtual());
    asset_ = p;
  }
  return asset_;
}
inline ::tradingpb::Asset* Strategy::mutable_asset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.asset)
  return _internal_mutable_asset();
}
inline void Strategy::set_allocated_asset(::tradingpb::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.asset)
}

// repeated .tradingpb.CtrlCondition buy = 3;
inline int Strategy::_internal_buy_size() const {
  return buy_.size();
}
inline int Strategy::buy_size() const {
  return _internal_buy_size();
}
inline void Strategy::clear_buy() {
  buy_.Clear();
}
inline ::tradingpb::CtrlCondition* Strategy::mutable_buy(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.buy)
  return buy_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
Strategy::mutable_buy() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Strategy.buy)
  return &buy_;
}
inline const ::tradingpb::CtrlCondition& Strategy::_internal_buy(int index) const {
  return buy_.Get(index);
}
inline const ::tradingpb::CtrlCondition& Strategy::buy(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.buy)
  return _internal_buy(index);
}
inline ::tradingpb::CtrlCondition* Strategy::_internal_add_buy() {
  return buy_.Add();
}
inline ::tradingpb::CtrlCondition* Strategy::add_buy() {
  // @@protoc_insertion_point(field_add:tradingpb.Strategy.buy)
  return _internal_add_buy();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
Strategy::buy() const {
  // @@protoc_insertion_point(field_list:tradingpb.Strategy.buy)
  return buy_;
}

// repeated .tradingpb.CtrlCondition sell = 4;
inline int Strategy::_internal_sell_size() const {
  return sell_.size();
}
inline int Strategy::sell_size() const {
  return _internal_sell_size();
}
inline void Strategy::clear_sell() {
  sell_.Clear();
}
inline ::tradingpb::CtrlCondition* Strategy::mutable_sell(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.sell)
  return sell_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
Strategy::mutable_sell() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Strategy.sell)
  return &sell_;
}
inline const ::tradingpb::CtrlCondition& Strategy::_internal_sell(int index) const {
  return sell_.Get(index);
}
inline const ::tradingpb::CtrlCondition& Strategy::sell(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.sell)
  return _internal_sell(index);
}
inline ::tradingpb::CtrlCondition* Strategy::_internal_add_sell() {
  return sell_.Add();
}
inline ::tradingpb::CtrlCondition* Strategy::add_sell() {
  // @@protoc_insertion_point(field_add:tradingpb.Strategy.sell)
  return _internal_add_sell();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
Strategy::sell() const {
  // @@protoc_insertion_point(field_list:tradingpb.Strategy.sell)
  return sell_;
}

// repeated .tradingpb.CtrlCondition stoploss = 5;
inline int Strategy::_internal_stoploss_size() const {
  return stoploss_.size();
}
inline int Strategy::stoploss_size() const {
  return _internal_stoploss_size();
}
inline void Strategy::clear_stoploss() {
  stoploss_.Clear();
}
inline ::tradingpb::CtrlCondition* Strategy::mutable_stoploss(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.stoploss)
  return stoploss_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
Strategy::mutable_stoploss() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Strategy.stoploss)
  return &stoploss_;
}
inline const ::tradingpb::CtrlCondition& Strategy::_internal_stoploss(int index) const {
  return stoploss_.Get(index);
}
inline const ::tradingpb::CtrlCondition& Strategy::stoploss(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.stoploss)
  return _internal_stoploss(index);
}
inline ::tradingpb::CtrlCondition* Strategy::_internal_add_stoploss() {
  return stoploss_.Add();
}
inline ::tradingpb::CtrlCondition* Strategy::add_stoploss() {
  // @@protoc_insertion_point(field_add:tradingpb.Strategy.stoploss)
  return _internal_add_stoploss();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
Strategy::stoploss() const {
  // @@protoc_insertion_point(field_list:tradingpb.Strategy.stoploss)
  return stoploss_;
}

// repeated .tradingpb.CtrlCondition takeprofit = 6;
inline int Strategy::_internal_takeprofit_size() const {
  return takeprofit_.size();
}
inline int Strategy::takeprofit_size() const {
  return _internal_takeprofit_size();
}
inline void Strategy::clear_takeprofit() {
  takeprofit_.Clear();
}
inline ::tradingpb::CtrlCondition* Strategy::mutable_takeprofit(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.takeprofit)
  return takeprofit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >*
Strategy::mutable_takeprofit() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Strategy.takeprofit)
  return &takeprofit_;
}
inline const ::tradingpb::CtrlCondition& Strategy::_internal_takeprofit(int index) const {
  return takeprofit_.Get(index);
}
inline const ::tradingpb::CtrlCondition& Strategy::takeprofit(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.takeprofit)
  return _internal_takeprofit(index);
}
inline ::tradingpb::CtrlCondition* Strategy::_internal_add_takeprofit() {
  return takeprofit_.Add();
}
inline ::tradingpb::CtrlCondition* Strategy::add_takeprofit() {
  // @@protoc_insertion_point(field_add:tradingpb.Strategy.takeprofit)
  return _internal_add_takeprofit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlCondition >&
Strategy::takeprofit() const {
  // @@protoc_insertion_point(field_list:tradingpb.Strategy.takeprofit)
  return takeprofit_;
}

// .tradingpb.BuyParams paramsBuy = 7;
inline bool Strategy::_internal_has_paramsbuy() const {
  return this != internal_default_instance() && paramsbuy_ != nullptr;
}
inline bool Strategy::has_paramsbuy() const {
  return _internal_has_paramsbuy();
}
inline void Strategy::clear_paramsbuy() {
  if (GetArenaNoVirtual() == nullptr && paramsbuy_ != nullptr) {
    delete paramsbuy_;
  }
  paramsbuy_ = nullptr;
}
inline const ::tradingpb::BuyParams& Strategy::_internal_paramsbuy() const {
  const ::tradingpb::BuyParams* p = paramsbuy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::BuyParams*>(
      &::tradingpb::_BuyParams_default_instance_);
}
inline const ::tradingpb::BuyParams& Strategy::paramsbuy() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.paramsBuy)
  return _internal_paramsbuy();
}
inline ::tradingpb::BuyParams* Strategy::release_paramsbuy() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.paramsBuy)
  
  ::tradingpb::BuyParams* temp = paramsbuy_;
  paramsbuy_ = nullptr;
  return temp;
}
inline ::tradingpb::BuyParams* Strategy::_internal_mutable_paramsbuy() {
  
  if (paramsbuy_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::BuyParams>(GetArenaNoVirtual());
    paramsbuy_ = p;
  }
  return paramsbuy_;
}
inline ::tradingpb::BuyParams* Strategy::mutable_paramsbuy() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.paramsBuy)
  return _internal_mutable_paramsbuy();
}
inline void Strategy::set_allocated_paramsbuy(::tradingpb::BuyParams* paramsbuy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paramsbuy_;
  }
  if (paramsbuy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paramsbuy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paramsbuy, submessage_arena);
    }
    
  } else {
    
  }
  paramsbuy_ = paramsbuy;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.paramsBuy)
}

// .tradingpb.SellParams paramsSell = 8;
inline bool Strategy::_internal_has_paramssell() const {
  return this != internal_default_instance() && paramssell_ != nullptr;
}
inline bool Strategy::has_paramssell() const {
  return _internal_has_paramssell();
}
inline void Strategy::clear_paramssell() {
  if (GetArenaNoVirtual() == nullptr && paramssell_ != nullptr) {
    delete paramssell_;
  }
  paramssell_ = nullptr;
}
inline const ::tradingpb::SellParams& Strategy::_internal_paramssell() const {
  const ::tradingpb::SellParams* p = paramssell_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::SellParams*>(
      &::tradingpb::_SellParams_default_instance_);
}
inline const ::tradingpb::SellParams& Strategy::paramssell() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.paramsSell)
  return _internal_paramssell();
}
inline ::tradingpb::SellParams* Strategy::release_paramssell() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.paramsSell)
  
  ::tradingpb::SellParams* temp = paramssell_;
  paramssell_ = nullptr;
  return temp;
}
inline ::tradingpb::SellParams* Strategy::_internal_mutable_paramssell() {
  
  if (paramssell_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::SellParams>(GetArenaNoVirtual());
    paramssell_ = p;
  }
  return paramssell_;
}
inline ::tradingpb::SellParams* Strategy::mutable_paramssell() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.paramsSell)
  return _internal_mutable_paramssell();
}
inline void Strategy::set_allocated_paramssell(::tradingpb::SellParams* paramssell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paramssell_;
  }
  if (paramssell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paramssell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paramssell, submessage_arena);
    }
    
  } else {
    
  }
  paramssell_ = paramssell;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.paramsSell)
}

// .tradingpb.StopLossParams paramsStopLoss = 9;
inline bool Strategy::_internal_has_paramsstoploss() const {
  return this != internal_default_instance() && paramsstoploss_ != nullptr;
}
inline bool Strategy::has_paramsstoploss() const {
  return _internal_has_paramsstoploss();
}
inline void Strategy::clear_paramsstoploss() {
  if (GetArenaNoVirtual() == nullptr && paramsstoploss_ != nullptr) {
    delete paramsstoploss_;
  }
  paramsstoploss_ = nullptr;
}
inline const ::tradingpb::StopLossParams& Strategy::_internal_paramsstoploss() const {
  const ::tradingpb::StopLossParams* p = paramsstoploss_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::StopLossParams*>(
      &::tradingpb::_StopLossParams_default_instance_);
}
inline const ::tradingpb::StopLossParams& Strategy::paramsstoploss() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.paramsStopLoss)
  return _internal_paramsstoploss();
}
inline ::tradingpb::StopLossParams* Strategy::release_paramsstoploss() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.paramsStopLoss)
  
  ::tradingpb::StopLossParams* temp = paramsstoploss_;
  paramsstoploss_ = nullptr;
  return temp;
}
inline ::tradingpb::StopLossParams* Strategy::_internal_mutable_paramsstoploss() {
  
  if (paramsstoploss_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::StopLossParams>(GetArenaNoVirtual());
    paramsstoploss_ = p;
  }
  return paramsstoploss_;
}
inline ::tradingpb::StopLossParams* Strategy::mutable_paramsstoploss() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.paramsStopLoss)
  return _internal_mutable_paramsstoploss();
}
inline void Strategy::set_allocated_paramsstoploss(::tradingpb::StopLossParams* paramsstoploss) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paramsstoploss_;
  }
  if (paramsstoploss) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paramsstoploss = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paramsstoploss, submessage_arena);
    }
    
  } else {
    
  }
  paramsstoploss_ = paramsstoploss;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.paramsStopLoss)
}

// .tradingpb.TakeProfitParams paramsTakeProfit = 10;
inline bool Strategy::_internal_has_paramstakeprofit() const {
  return this != internal_default_instance() && paramstakeprofit_ != nullptr;
}
inline bool Strategy::has_paramstakeprofit() const {
  return _internal_has_paramstakeprofit();
}
inline void Strategy::clear_paramstakeprofit() {
  if (GetArenaNoVirtual() == nullptr && paramstakeprofit_ != nullptr) {
    delete paramstakeprofit_;
  }
  paramstakeprofit_ = nullptr;
}
inline const ::tradingpb::TakeProfitParams& Strategy::_internal_paramstakeprofit() const {
  const ::tradingpb::TakeProfitParams* p = paramstakeprofit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::TakeProfitParams*>(
      &::tradingpb::_TakeProfitParams_default_instance_);
}
inline const ::tradingpb::TakeProfitParams& Strategy::paramstakeprofit() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.paramsTakeProfit)
  return _internal_paramstakeprofit();
}
inline ::tradingpb::TakeProfitParams* Strategy::release_paramstakeprofit() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.paramsTakeProfit)
  
  ::tradingpb::TakeProfitParams* temp = paramstakeprofit_;
  paramstakeprofit_ = nullptr;
  return temp;
}
inline ::tradingpb::TakeProfitParams* Strategy::_internal_mutable_paramstakeprofit() {
  
  if (paramstakeprofit_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::TakeProfitParams>(GetArenaNoVirtual());
    paramstakeprofit_ = p;
  }
  return paramstakeprofit_;
}
inline ::tradingpb::TakeProfitParams* Strategy::mutable_paramstakeprofit() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.paramsTakeProfit)
  return _internal_mutable_paramstakeprofit();
}
inline void Strategy::set_allocated_paramstakeprofit(::tradingpb::TakeProfitParams* paramstakeprofit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paramstakeprofit_;
  }
  if (paramstakeprofit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paramstakeprofit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paramstakeprofit, submessage_arena);
    }
    
  } else {
    
  }
  paramstakeprofit_ = paramstakeprofit;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.paramsTakeProfit)
}

// .tradingpb.InitParams paramsInit = 11;
inline bool Strategy::_internal_has_paramsinit() const {
  return this != internal_default_instance() && paramsinit_ != nullptr;
}
inline bool Strategy::has_paramsinit() const {
  return _internal_has_paramsinit();
}
inline void Strategy::clear_paramsinit() {
  if (GetArenaNoVirtual() == nullptr && paramsinit_ != nullptr) {
    delete paramsinit_;
  }
  paramsinit_ = nullptr;
}
inline const ::tradingpb::InitParams& Strategy::_internal_paramsinit() const {
  const ::tradingpb::InitParams* p = paramsinit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::InitParams*>(
      &::tradingpb::_InitParams_default_instance_);
}
inline const ::tradingpb::InitParams& Strategy::paramsinit() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.paramsInit)
  return _internal_paramsinit();
}
inline ::tradingpb::InitParams* Strategy::release_paramsinit() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.paramsInit)
  
  ::tradingpb::InitParams* temp = paramsinit_;
  paramsinit_ = nullptr;
  return temp;
}
inline ::tradingpb::InitParams* Strategy::_internal_mutable_paramsinit() {
  
  if (paramsinit_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::InitParams>(GetArenaNoVirtual());
    paramsinit_ = p;
  }
  return paramsinit_;
}
inline ::tradingpb::InitParams* Strategy::mutable_paramsinit() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.paramsInit)
  return _internal_mutable_paramsinit();
}
inline void Strategy::set_allocated_paramsinit(::tradingpb::InitParams* paramsinit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paramsinit_;
  }
  if (paramsinit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paramsinit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paramsinit, submessage_arena);
    }
    
  } else {
    
  }
  paramsinit_ = paramsinit;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.paramsInit)
}

// .tradingpb.AIPParams paramsAIP = 12;
inline bool Strategy::_internal_has_paramsaip() const {
  return this != internal_default_instance() && paramsaip_ != nullptr;
}
inline bool Strategy::has_paramsaip() const {
  return _internal_has_paramsaip();
}
inline void Strategy::clear_paramsaip() {
  if (GetArenaNoVirtual() == nullptr && paramsaip_ != nullptr) {
    delete paramsaip_;
  }
  paramsaip_ = nullptr;
}
inline const ::tradingpb::AIPParams& Strategy::_internal_paramsaip() const {
  const ::tradingpb::AIPParams* p = paramsaip_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::AIPParams*>(
      &::tradingpb::_AIPParams_default_instance_);
}
inline const ::tradingpb::AIPParams& Strategy::paramsaip() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.paramsAIP)
  return _internal_paramsaip();
}
inline ::tradingpb::AIPParams* Strategy::release_paramsaip() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.paramsAIP)
  
  ::tradingpb::AIPParams* temp = paramsaip_;
  paramsaip_ = nullptr;
  return temp;
}
inline ::tradingpb::AIPParams* Strategy::_internal_mutable_paramsaip() {
  
  if (paramsaip_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::AIPParams>(GetArenaNoVirtual());
    paramsaip_ = p;
  }
  return paramsaip_;
}
inline ::tradingpb::AIPParams* Strategy::mutable_paramsaip() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.paramsAIP)
  return _internal_mutable_paramsaip();
}
inline void Strategy::set_allocated_paramsaip(::tradingpb::AIPParams* paramsaip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paramsaip_;
  }
  if (paramsaip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paramsaip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paramsaip, submessage_arena);
    }
    
  } else {
    
  }
  paramsaip_ = paramsaip;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.paramsAIP)
}

// string title = 13 [deprecated = true];
inline void Strategy::clear_title() {
  title_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Strategy::title() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.title)
  return _internal_title();
}
inline void Strategy::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:tradingpb.Strategy.title)
}
inline std::string* Strategy::mutable_title() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.title)
  return _internal_mutable_title();
}
inline const std::string& Strategy::_internal_title() const {
  return title_.GetNoArena();
}
inline void Strategy::_internal_set_title(const std::string& value) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Strategy::set_title(std::string&& value) {
  
  title_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.Strategy.title)
}
inline void Strategy::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.Strategy.title)
}
inline void Strategy::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Strategy.title)
}
inline std::string* Strategy::_internal_mutable_title() {
  
  return title_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Strategy::release_title() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.title)
  
  return title_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Strategy::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.title)
}

// repeated string indicators = 14;
inline int Strategy::_internal_indicators_size() const {
  return indicators_.size();
}
inline int Strategy::indicators_size() const {
  return _internal_indicators_size();
}
inline void Strategy::clear_indicators() {
  indicators_.Clear();
}
inline std::string* Strategy::add_indicators() {
  // @@protoc_insertion_point(field_add_mutable:tradingpb.Strategy.indicators)
  return _internal_add_indicators();
}
inline const std::string& Strategy::_internal_indicators(int index) const {
  return indicators_.Get(index);
}
inline const std::string& Strategy::indicators(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.indicators)
  return _internal_indicators(index);
}
inline std::string* Strategy::mutable_indicators(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.indicators)
  return indicators_.Mutable(index);
}
inline void Strategy::set_indicators(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tradingpb.Strategy.indicators)
  indicators_.Mutable(index)->assign(value);
}
inline void Strategy::set_indicators(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tradingpb.Strategy.indicators)
  indicators_.Mutable(index)->assign(std::move(value));
}
inline void Strategy::set_indicators(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  indicators_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tradingpb.Strategy.indicators)
}
inline void Strategy::set_indicators(int index, const char* value, size_t size) {
  indicators_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tradingpb.Strategy.indicators)
}
inline std::string* Strategy::_internal_add_indicators() {
  return indicators_.Add();
}
inline void Strategy::add_indicators(const std::string& value) {
  indicators_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tradingpb.Strategy.indicators)
}
inline void Strategy::add_indicators(std::string&& value) {
  indicators_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tradingpb.Strategy.indicators)
}
inline void Strategy::add_indicators(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  indicators_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tradingpb.Strategy.indicators)
}
inline void Strategy::add_indicators(const char* value, size_t size) {
  indicators_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tradingpb.Strategy.indicators)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Strategy::indicators() const {
  // @@protoc_insertion_point(field_list:tradingpb.Strategy.indicators)
  return indicators_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Strategy::mutable_indicators() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.Strategy.indicators)
  return &indicators_;
}

// .tradingpb.FeeParams feeBuy = 15;
inline bool Strategy::_internal_has_feebuy() const {
  return this != internal_default_instance() && feebuy_ != nullptr;
}
inline bool Strategy::has_feebuy() const {
  return _internal_has_feebuy();
}
inline void Strategy::clear_feebuy() {
  if (GetArenaNoVirtual() == nullptr && feebuy_ != nullptr) {
    delete feebuy_;
  }
  feebuy_ = nullptr;
}
inline const ::tradingpb::FeeParams& Strategy::_internal_feebuy() const {
  const ::tradingpb::FeeParams* p = feebuy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::FeeParams*>(
      &::tradingpb::_FeeParams_default_instance_);
}
inline const ::tradingpb::FeeParams& Strategy::feebuy() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.feeBuy)
  return _internal_feebuy();
}
inline ::tradingpb::FeeParams* Strategy::release_feebuy() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.feeBuy)
  
  ::tradingpb::FeeParams* temp = feebuy_;
  feebuy_ = nullptr;
  return temp;
}
inline ::tradingpb::FeeParams* Strategy::_internal_mutable_feebuy() {
  
  if (feebuy_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::FeeParams>(GetArenaNoVirtual());
    feebuy_ = p;
  }
  return feebuy_;
}
inline ::tradingpb::FeeParams* Strategy::mutable_feebuy() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.feeBuy)
  return _internal_mutable_feebuy();
}
inline void Strategy::set_allocated_feebuy(::tradingpb::FeeParams* feebuy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete feebuy_;
  }
  if (feebuy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      feebuy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feebuy, submessage_arena);
    }
    
  } else {
    
  }
  feebuy_ = feebuy;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.feeBuy)
}

// .tradingpb.FeeParams feeSell = 16;
inline bool Strategy::_internal_has_feesell() const {
  return this != internal_default_instance() && feesell_ != nullptr;
}
inline bool Strategy::has_feesell() const {
  return _internal_has_feesell();
}
inline void Strategy::clear_feesell() {
  if (GetArenaNoVirtual() == nullptr && feesell_ != nullptr) {
    delete feesell_;
  }
  feesell_ = nullptr;
}
inline const ::tradingpb::FeeParams& Strategy::_internal_feesell() const {
  const ::tradingpb::FeeParams* p = feesell_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::FeeParams*>(
      &::tradingpb::_FeeParams_default_instance_);
}
inline const ::tradingpb::FeeParams& Strategy::feesell() const {
  // @@protoc_insertion_point(field_get:tradingpb.Strategy.feeSell)
  return _internal_feesell();
}
inline ::tradingpb::FeeParams* Strategy::release_feesell() {
  // @@protoc_insertion_point(field_release:tradingpb.Strategy.feeSell)
  
  ::tradingpb::FeeParams* temp = feesell_;
  feesell_ = nullptr;
  return temp;
}
inline ::tradingpb::FeeParams* Strategy::_internal_mutable_feesell() {
  
  if (feesell_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::FeeParams>(GetArenaNoVirtual());
    feesell_ = p;
  }
  return feesell_;
}
inline ::tradingpb::FeeParams* Strategy::mutable_feesell() {
  // @@protoc_insertion_point(field_mutable:tradingpb.Strategy.feeSell)
  return _internal_mutable_feesell();
}
inline void Strategy::set_allocated_feesell(::tradingpb::FeeParams* feesell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete feesell_;
  }
  if (feesell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      feesell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feesell, submessage_arena);
    }
    
  } else {
    
  }
  feesell_ = feesell;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.Strategy.feeSell)
}

// -------------------------------------------------------------------

// PNLDataValue

// int64 ts = 1;
inline void PNLDataValue::clear_ts() {
  ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLDataValue::_internal_ts() const {
  return ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLDataValue::ts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.ts)
  return _internal_ts();
}
inline void PNLDataValue::_internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ts_ = value;
}
inline void PNLDataValue::set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.ts)
}

// float perValue = 2;
inline void PNLDataValue::clear_pervalue() {
  pervalue_ = 0;
}
inline float PNLDataValue::_internal_pervalue() const {
  return pervalue_;
}
inline float PNLDataValue::pervalue() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.perValue)
  return _internal_pervalue();
}
inline void PNLDataValue::_internal_set_pervalue(float value) {
  
  pervalue_ = value;
}
inline void PNLDataValue::set_pervalue(float value) {
  _internal_set_pervalue(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.perValue)
}

// repeated string tags = 3;
inline int PNLDataValue::_internal_tags_size() const {
  return tags_.size();
}
inline int PNLDataValue::tags_size() const {
  return _internal_tags_size();
}
inline void PNLDataValue::clear_tags() {
  tags_.Clear();
}
inline std::string* PNLDataValue::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:tradingpb.PNLDataValue.tags)
  return _internal_add_tags();
}
inline const std::string& PNLDataValue::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& PNLDataValue::tags(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.tags)
  return _internal_tags(index);
}
inline std::string* PNLDataValue::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLDataValue.tags)
  return tags_.Mutable(index);
}
inline void PNLDataValue::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.tags)
  tags_.Mutable(index)->assign(value);
}
inline void PNLDataValue::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void PNLDataValue::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tradingpb.PNLDataValue.tags)
}
inline void PNLDataValue::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tradingpb.PNLDataValue.tags)
}
inline std::string* PNLDataValue::_internal_add_tags() {
  return tags_.Add();
}
inline void PNLDataValue::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tradingpb.PNLDataValue.tags)
}
inline void PNLDataValue::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tradingpb.PNLDataValue.tags)
}
inline void PNLDataValue::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tradingpb.PNLDataValue.tags)
}
inline void PNLDataValue::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tradingpb.PNLDataValue.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PNLDataValue::tags() const {
  // @@protoc_insertion_point(field_list:tradingpb.PNLDataValue.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PNLDataValue::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.PNLDataValue.tags)
  return &tags_;
}

// float cost = 4;
inline void PNLDataValue::clear_cost() {
  cost_ = 0;
}
inline float PNLDataValue::_internal_cost() const {
  return cost_;
}
inline float PNLDataValue::cost() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.cost)
  return _internal_cost();
}
inline void PNLDataValue::_internal_set_cost(float value) {
  
  cost_ = value;
}
inline void PNLDataValue::set_cost(float value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.cost)
}

// float value = 5;
inline void PNLDataValue::clear_value() {
  value_ = 0;
}
inline float PNLDataValue::_internal_value() const {
  return value_;
}
inline float PNLDataValue::value() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.value)
  return _internal_value();
}
inline void PNLDataValue::_internal_set_value(float value) {
  
  value_ = value;
}
inline void PNLDataValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.value)
}

// float volume = 6;
inline void PNLDataValue::clear_volume() {
  volume_ = 0;
}
inline float PNLDataValue::_internal_volume() const {
  return volume_;
}
inline float PNLDataValue::volume() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.volume)
  return _internal_volume();
}
inline void PNLDataValue::_internal_set_volume(float value) {
  
  volume_ = value;
}
inline void PNLDataValue::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.volume)
}

// float price = 7;
inline void PNLDataValue::clear_price() {
  price_ = 0;
}
inline float PNLDataValue::_internal_price() const {
  return price_;
}
inline float PNLDataValue::price() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLDataValue.price)
  return _internal_price();
}
inline void PNLDataValue::_internal_set_price(float value) {
  
  price_ = value;
}
inline void PNLDataValue::set_price(float value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLDataValue.price)
}

// -------------------------------------------------------------------

// PNLAssetData

// .tradingpb.Asset asset = 1;
inline bool PNLAssetData::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool PNLAssetData::has_asset() const {
  return _internal_has_asset();
}
inline void PNLAssetData::clear_asset() {
  if (GetArenaNoVirtual() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::tradingpb::Asset& PNLAssetData::_internal_asset() const {
  const ::tradingpb::Asset* p = asset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::Asset*>(
      &::tradingpb::_Asset_default_instance_);
}
inline const ::tradingpb::Asset& PNLAssetData::asset() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.asset)
  return _internal_asset();
}
inline ::tradingpb::Asset* PNLAssetData::release_asset() {
  // @@protoc_insertion_point(field_release:tradingpb.PNLAssetData.asset)
  
  ::tradingpb::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::tradingpb::Asset* PNLAssetData::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::Asset>(GetArenaNoVirtual());
    asset_ = p;
  }
  return asset_;
}
inline ::tradingpb::Asset* PNLAssetData::mutable_asset() {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLAssetData.asset)
  return _internal_mutable_asset();
}
inline void PNLAssetData::set_allocated_asset(::tradingpb::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.PNLAssetData.asset)
}

// repeated .tradingpb.PNLDataValue values = 2;
inline int PNLAssetData::_internal_values_size() const {
  return values_.size();
}
inline int PNLAssetData::values_size() const {
  return _internal_values_size();
}
inline void PNLAssetData::clear_values() {
  values_.Clear();
}
inline ::tradingpb::PNLDataValue* PNLAssetData::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLAssetData.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLDataValue >*
PNLAssetData::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.PNLAssetData.values)
  return &values_;
}
inline const ::tradingpb::PNLDataValue& PNLAssetData::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::tradingpb::PNLDataValue& PNLAssetData::values(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.values)
  return _internal_values(index);
}
inline ::tradingpb::PNLDataValue* PNLAssetData::_internal_add_values() {
  return values_.Add();
}
inline ::tradingpb::PNLDataValue* PNLAssetData::add_values() {
  // @@protoc_insertion_point(field_add:tradingpb.PNLAssetData.values)
  return _internal_add_values();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLDataValue >&
PNLAssetData::values() const {
  // @@protoc_insertion_point(field_list:tradingpb.PNLAssetData.values)
  return values_;
}

// float maxDrawdown = 3;
inline void PNLAssetData::clear_maxdrawdown() {
  maxdrawdown_ = 0;
}
inline float PNLAssetData::_internal_maxdrawdown() const {
  return maxdrawdown_;
}
inline float PNLAssetData::maxdrawdown() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDrawdown)
  return _internal_maxdrawdown();
}
inline void PNLAssetData::_internal_set_maxdrawdown(float value) {
  
  maxdrawdown_ = value;
}
inline void PNLAssetData::set_maxdrawdown(float value) {
  _internal_set_maxdrawdown(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDrawdown)
}

// int64 maxDrawdownStartTs = 4;
inline void PNLAssetData::clear_maxdrawdownstartts() {
  maxdrawdownstartts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdrawdownstartts() const {
  return maxdrawdownstartts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdrawdownstartts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDrawdownStartTs)
  return _internal_maxdrawdownstartts();
}
inline void PNLAssetData::_internal_set_maxdrawdownstartts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdrawdownstartts_ = value;
}
inline void PNLAssetData::set_maxdrawdownstartts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdrawdownstartts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDrawdownStartTs)
}

// int64 maxDrawdownEndTs = 5;
inline void PNLAssetData::clear_maxdrawdownendts() {
  maxdrawdownendts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdrawdownendts() const {
  return maxdrawdownendts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdrawdownendts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDrawdownEndTs)
  return _internal_maxdrawdownendts();
}
inline void PNLAssetData::_internal_set_maxdrawdownendts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdrawdownendts_ = value;
}
inline void PNLAssetData::set_maxdrawdownendts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdrawdownendts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDrawdownEndTs)
}

// float maxDrawup = 6;
inline void PNLAssetData::clear_maxdrawup() {
  maxdrawup_ = 0;
}
inline float PNLAssetData::_internal_maxdrawup() const {
  return maxdrawup_;
}
inline float PNLAssetData::maxdrawup() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDrawup)
  return _internal_maxdrawup();
}
inline void PNLAssetData::_internal_set_maxdrawup(float value) {
  
  maxdrawup_ = value;
}
inline void PNLAssetData::set_maxdrawup(float value) {
  _internal_set_maxdrawup(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDrawup)
}

// int64 maxDrawupStartTs = 7;
inline void PNLAssetData::clear_maxdrawupstartts() {
  maxdrawupstartts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdrawupstartts() const {
  return maxdrawupstartts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdrawupstartts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDrawupStartTs)
  return _internal_maxdrawupstartts();
}
inline void PNLAssetData::_internal_set_maxdrawupstartts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdrawupstartts_ = value;
}
inline void PNLAssetData::set_maxdrawupstartts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdrawupstartts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDrawupStartTs)
}

// int64 maxDrawupEndTs = 8;
inline void PNLAssetData::clear_maxdrawupendts() {
  maxdrawupendts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdrawupendts() const {
  return maxdrawupendts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdrawupendts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDrawupEndTs)
  return _internal_maxdrawupendts();
}
inline void PNLAssetData::_internal_set_maxdrawupendts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdrawupendts_ = value;
}
inline void PNLAssetData::set_maxdrawupendts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdrawupendts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDrawupEndTs)
}

// float sharpe = 9;
inline void PNLAssetData::clear_sharpe() {
  sharpe_ = 0;
}
inline float PNLAssetData::_internal_sharpe() const {
  return sharpe_;
}
inline float PNLAssetData::sharpe() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.sharpe)
  return _internal_sharpe();
}
inline void PNLAssetData::_internal_set_sharpe(float value) {
  
  sharpe_ = value;
}
inline void PNLAssetData::set_sharpe(float value) {
  _internal_set_sharpe(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.sharpe)
}

// float annualizedReturns = 10;
inline void PNLAssetData::clear_annualizedreturns() {
  annualizedreturns_ = 0;
}
inline float PNLAssetData::_internal_annualizedreturns() const {
  return annualizedreturns_;
}
inline float PNLAssetData::annualizedreturns() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.annualizedReturns)
  return _internal_annualizedreturns();
}
inline void PNLAssetData::_internal_set_annualizedreturns(float value) {
  
  annualizedreturns_ = value;
}
inline void PNLAssetData::set_annualizedreturns(float value) {
  _internal_set_annualizedreturns(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.annualizedReturns)
}

// float annualizedVolatility = 11;
inline void PNLAssetData::clear_annualizedvolatility() {
  annualizedvolatility_ = 0;
}
inline float PNLAssetData::_internal_annualizedvolatility() const {
  return annualizedvolatility_;
}
inline float PNLAssetData::annualizedvolatility() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.annualizedVolatility)
  return _internal_annualizedvolatility();
}
inline void PNLAssetData::_internal_set_annualizedvolatility(float value) {
  
  annualizedvolatility_ = value;
}
inline void PNLAssetData::set_annualizedvolatility(float value) {
  _internal_set_annualizedvolatility(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.annualizedVolatility)
}

// float totalReturns = 12;
inline void PNLAssetData::clear_totalreturns() {
  totalreturns_ = 0;
}
inline float PNLAssetData::_internal_totalreturns() const {
  return totalreturns_;
}
inline float PNLAssetData::totalreturns() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.totalReturns)
  return _internal_totalreturns();
}
inline void PNLAssetData::_internal_set_totalreturns(float value) {
  
  totalreturns_ = value;
}
inline void PNLAssetData::set_totalreturns(float value) {
  _internal_set_totalreturns(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.totalReturns)
}

// float variance = 13;
inline void PNLAssetData::clear_variance() {
  variance_ = 0;
}
inline float PNLAssetData::_internal_variance() const {
  return variance_;
}
inline float PNLAssetData::variance() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.variance)
  return _internal_variance();
}
inline void PNLAssetData::_internal_set_variance(float value) {
  
  variance_ = value;
}
inline void PNLAssetData::set_variance(float value) {
  _internal_set_variance(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.variance)
}

// int32 buyTimes = 14;
inline void PNLAssetData::clear_buytimes() {
  buytimes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::_internal_buytimes() const {
  return buytimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::buytimes() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.buyTimes)
  return _internal_buytimes();
}
inline void PNLAssetData::_internal_set_buytimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  buytimes_ = value;
}
inline void PNLAssetData::set_buytimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_buytimes(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.buyTimes)
}

// int32 sellTimes = 15;
inline void PNLAssetData::clear_selltimes() {
  selltimes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::_internal_selltimes() const {
  return selltimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::selltimes() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.sellTimes)
  return _internal_selltimes();
}
inline void PNLAssetData::_internal_set_selltimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  selltimes_ = value;
}
inline void PNLAssetData::set_selltimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_selltimes(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.sellTimes)
}

// int32 stoplossTimes = 16;
inline void PNLAssetData::clear_stoplosstimes() {
  stoplosstimes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::_internal_stoplosstimes() const {
  return stoplosstimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::stoplosstimes() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.stoplossTimes)
  return _internal_stoplosstimes();
}
inline void PNLAssetData::_internal_set_stoplosstimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  stoplosstimes_ = value;
}
inline void PNLAssetData::set_stoplosstimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stoplosstimes(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.stoplossTimes)
}

// int64 maxUpDayTs = 17;
inline void PNLAssetData::clear_maxupdayts() {
  maxupdayts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxupdayts() const {
  return maxupdayts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxupdayts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxUpDayTs)
  return _internal_maxupdayts();
}
inline void PNLAssetData::_internal_set_maxupdayts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxupdayts_ = value;
}
inline void PNLAssetData::set_maxupdayts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxupdayts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxUpDayTs)
}

// float maxPerUpDay = 18;
inline void PNLAssetData::clear_maxperupday() {
  maxperupday_ = 0;
}
inline float PNLAssetData::_internal_maxperupday() const {
  return maxperupday_;
}
inline float PNLAssetData::maxperupday() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerUpDay)
  return _internal_maxperupday();
}
inline void PNLAssetData::_internal_set_maxperupday(float value) {
  
  maxperupday_ = value;
}
inline void PNLAssetData::set_maxperupday(float value) {
  _internal_set_maxperupday(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerUpDay)
}

// int64 maxDownDayTs = 19;
inline void PNLAssetData::clear_maxdowndayts() {
  maxdowndayts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdowndayts() const {
  return maxdowndayts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdowndayts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDownDayTs)
  return _internal_maxdowndayts();
}
inline void PNLAssetData::_internal_set_maxdowndayts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdowndayts_ = value;
}
inline void PNLAssetData::set_maxdowndayts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdowndayts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDownDayTs)
}

// float maxPerDownDay = 20;
inline void PNLAssetData::clear_maxperdownday() {
  maxperdownday_ = 0;
}
inline float PNLAssetData::_internal_maxperdownday() const {
  return maxperdownday_;
}
inline float PNLAssetData::maxperdownday() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerDownDay)
  return _internal_maxperdownday();
}
inline void PNLAssetData::_internal_set_maxperdownday(float value) {
  
  maxperdownday_ = value;
}
inline void PNLAssetData::set_maxperdownday(float value) {
  _internal_set_maxperdownday(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerDownDay)
}

// int64 maxUpWeekTs = 21;
inline void PNLAssetData::clear_maxupweekts() {
  maxupweekts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxupweekts() const {
  return maxupweekts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxupweekts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxUpWeekTs)
  return _internal_maxupweekts();
}
inline void PNLAssetData::_internal_set_maxupweekts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxupweekts_ = value;
}
inline void PNLAssetData::set_maxupweekts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxupweekts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxUpWeekTs)
}

// float maxPerUpWeek = 22;
inline void PNLAssetData::clear_maxperupweek() {
  maxperupweek_ = 0;
}
inline float PNLAssetData::_internal_maxperupweek() const {
  return maxperupweek_;
}
inline float PNLAssetData::maxperupweek() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerUpWeek)
  return _internal_maxperupweek();
}
inline void PNLAssetData::_internal_set_maxperupweek(float value) {
  
  maxperupweek_ = value;
}
inline void PNLAssetData::set_maxperupweek(float value) {
  _internal_set_maxperupweek(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerUpWeek)
}

// int64 maxDownWeekTs = 23;
inline void PNLAssetData::clear_maxdownweekts() {
  maxdownweekts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdownweekts() const {
  return maxdownweekts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdownweekts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDownWeekTs)
  return _internal_maxdownweekts();
}
inline void PNLAssetData::_internal_set_maxdownweekts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdownweekts_ = value;
}
inline void PNLAssetData::set_maxdownweekts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdownweekts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDownWeekTs)
}

// float maxPerDownWeek = 24;
inline void PNLAssetData::clear_maxperdownweek() {
  maxperdownweek_ = 0;
}
inline float PNLAssetData::_internal_maxperdownweek() const {
  return maxperdownweek_;
}
inline float PNLAssetData::maxperdownweek() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerDownWeek)
  return _internal_maxperdownweek();
}
inline void PNLAssetData::_internal_set_maxperdownweek(float value) {
  
  maxperdownweek_ = value;
}
inline void PNLAssetData::set_maxperdownweek(float value) {
  _internal_set_maxperdownweek(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerDownWeek)
}

// int64 maxUpMonthTs = 25;
inline void PNLAssetData::clear_maxupmonthts() {
  maxupmonthts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxupmonthts() const {
  return maxupmonthts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxupmonthts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxUpMonthTs)
  return _internal_maxupmonthts();
}
inline void PNLAssetData::_internal_set_maxupmonthts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxupmonthts_ = value;
}
inline void PNLAssetData::set_maxupmonthts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxupmonthts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxUpMonthTs)
}

// float maxPerUpMonth = 26;
inline void PNLAssetData::clear_maxperupmonth() {
  maxperupmonth_ = 0;
}
inline float PNLAssetData::_internal_maxperupmonth() const {
  return maxperupmonth_;
}
inline float PNLAssetData::maxperupmonth() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerUpMonth)
  return _internal_maxperupmonth();
}
inline void PNLAssetData::_internal_set_maxperupmonth(float value) {
  
  maxperupmonth_ = value;
}
inline void PNLAssetData::set_maxperupmonth(float value) {
  _internal_set_maxperupmonth(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerUpMonth)
}

// int64 maxDownMonthTs = 27;
inline void PNLAssetData::clear_maxdownmonthts() {
  maxdownmonthts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdownmonthts() const {
  return maxdownmonthts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdownmonthts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDownMonthTs)
  return _internal_maxdownmonthts();
}
inline void PNLAssetData::_internal_set_maxdownmonthts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdownmonthts_ = value;
}
inline void PNLAssetData::set_maxdownmonthts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdownmonthts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDownMonthTs)
}

// float maxPerDownMonth = 28;
inline void PNLAssetData::clear_maxperdownmonth() {
  maxperdownmonth_ = 0;
}
inline float PNLAssetData::_internal_maxperdownmonth() const {
  return maxperdownmonth_;
}
inline float PNLAssetData::maxperdownmonth() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerDownMonth)
  return _internal_maxperdownmonth();
}
inline void PNLAssetData::_internal_set_maxperdownmonth(float value) {
  
  maxperdownmonth_ = value;
}
inline void PNLAssetData::set_maxperdownmonth(float value) {
  _internal_set_maxperdownmonth(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerDownMonth)
}

// int64 maxUpYearTs = 29;
inline void PNLAssetData::clear_maxupyearts() {
  maxupyearts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxupyearts() const {
  return maxupyearts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxupyearts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxUpYearTs)
  return _internal_maxupyearts();
}
inline void PNLAssetData::_internal_set_maxupyearts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxupyearts_ = value;
}
inline void PNLAssetData::set_maxupyearts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxupyearts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxUpYearTs)
}

// float maxPerUpYear = 30;
inline void PNLAssetData::clear_maxperupyear() {
  maxperupyear_ = 0;
}
inline float PNLAssetData::_internal_maxperupyear() const {
  return maxperupyear_;
}
inline float PNLAssetData::maxperupyear() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerUpYear)
  return _internal_maxperupyear();
}
inline void PNLAssetData::_internal_set_maxperupyear(float value) {
  
  maxperupyear_ = value;
}
inline void PNLAssetData::set_maxperupyear(float value) {
  _internal_set_maxperupyear(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerUpYear)
}

// int64 maxDownYearTs = 31;
inline void PNLAssetData::clear_maxdownyearts() {
  maxdownyearts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::_internal_maxdownyearts() const {
  return maxdownyearts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLAssetData::maxdownyearts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxDownYearTs)
  return _internal_maxdownyearts();
}
inline void PNLAssetData::_internal_set_maxdownyearts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  maxdownyearts_ = value;
}
inline void PNLAssetData::set_maxdownyearts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_maxdownyearts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxDownYearTs)
}

// float maxPerDownYear = 32;
inline void PNLAssetData::clear_maxperdownyear() {
  maxperdownyear_ = 0;
}
inline float PNLAssetData::_internal_maxperdownyear() const {
  return maxperdownyear_;
}
inline float PNLAssetData::maxperdownyear() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.maxPerDownYear)
  return _internal_maxperdownyear();
}
inline void PNLAssetData::_internal_set_maxperdownyear(float value) {
  
  maxperdownyear_ = value;
}
inline void PNLAssetData::set_maxperdownyear(float value) {
  _internal_set_maxperdownyear(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.maxPerDownYear)
}

// repeated .tradingpb.CtrlNode lstCtrl = 33;
inline int PNLAssetData::_internal_lstctrl_size() const {
  return lstctrl_.size();
}
inline int PNLAssetData::lstctrl_size() const {
  return _internal_lstctrl_size();
}
inline void PNLAssetData::clear_lstctrl() {
  lstctrl_.Clear();
}
inline ::tradingpb::CtrlNode* PNLAssetData::mutable_lstctrl(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLAssetData.lstCtrl)
  return lstctrl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlNode >*
PNLAssetData::mutable_lstctrl() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.PNLAssetData.lstCtrl)
  return &lstctrl_;
}
inline const ::tradingpb::CtrlNode& PNLAssetData::_internal_lstctrl(int index) const {
  return lstctrl_.Get(index);
}
inline const ::tradingpb::CtrlNode& PNLAssetData::lstctrl(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.lstCtrl)
  return _internal_lstctrl(index);
}
inline ::tradingpb::CtrlNode* PNLAssetData::_internal_add_lstctrl() {
  return lstctrl_.Add();
}
inline ::tradingpb::CtrlNode* PNLAssetData::add_lstctrl() {
  // @@protoc_insertion_point(field_add:tradingpb.PNLAssetData.lstCtrl)
  return _internal_add_lstctrl();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::CtrlNode >&
PNLAssetData::lstctrl() const {
  // @@protoc_insertion_point(field_list:tradingpb.PNLAssetData.lstCtrl)
  return lstctrl_;
}

// repeated .tradingpb.Indicator indicators = 34;
inline int PNLAssetData::_internal_indicators_size() const {
  return indicators_.size();
}
inline int PNLAssetData::indicators_size() const {
  return _internal_indicators_size();
}
inline void PNLAssetData::clear_indicators() {
  indicators_.Clear();
}
inline ::tradingpb::Indicator* PNLAssetData::mutable_indicators(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLAssetData.indicators)
  return indicators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Indicator >*
PNLAssetData::mutable_indicators() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.PNLAssetData.indicators)
  return &indicators_;
}
inline const ::tradingpb::Indicator& PNLAssetData::_internal_indicators(int index) const {
  return indicators_.Get(index);
}
inline const ::tradingpb::Indicator& PNLAssetData::indicators(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.indicators)
  return _internal_indicators(index);
}
inline ::tradingpb::Indicator* PNLAssetData::_internal_add_indicators() {
  return indicators_.Add();
}
inline ::tradingpb::Indicator* PNLAssetData::add_indicators() {
  // @@protoc_insertion_point(field_add:tradingpb.PNLAssetData.indicators)
  return _internal_add_indicators();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Indicator >&
PNLAssetData::indicators() const {
  // @@protoc_insertion_point(field_list:tradingpb.PNLAssetData.indicators)
  return indicators_;
}

// int32 winTimes = 35;
inline void PNLAssetData::clear_wintimes() {
  wintimes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::_internal_wintimes() const {
  return wintimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PNLAssetData::wintimes() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLAssetData.winTimes)
  return _internal_wintimes();
}
inline void PNLAssetData::_internal_set_wintimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wintimes_ = value;
}
inline void PNLAssetData::set_wintimes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wintimes(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLAssetData.winTimes)
}

// -------------------------------------------------------------------

// PNLData

// string name = 1 [deprecated = true];
inline void PNLData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PNLData::name() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLData.name)
  return _internal_name();
}
inline void PNLData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLData.name)
}
inline std::string* PNLData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLData.name)
  return _internal_mutable_name();
}
inline const std::string& PNLData::_internal_name() const {
  return name_.GetNoArena();
}
inline void PNLData::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PNLData::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.PNLData.name)
}
inline void PNLData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.PNLData.name)
}
inline void PNLData::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.PNLData.name)
}
inline std::string* PNLData::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PNLData::release_name() {
  // @@protoc_insertion_point(field_release:tradingpb.PNLData.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PNLData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.PNLData.name)
}

// .tradingpb.PNLAssetData total = 2;
inline bool PNLData::_internal_has_total() const {
  return this != internal_default_instance() && total_ != nullptr;
}
inline bool PNLData::has_total() const {
  return _internal_has_total();
}
inline void PNLData::clear_total() {
  if (GetArenaNoVirtual() == nullptr && total_ != nullptr) {
    delete total_;
  }
  total_ = nullptr;
}
inline const ::tradingpb::PNLAssetData& PNLData::_internal_total() const {
  const ::tradingpb::PNLAssetData* p = total_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::PNLAssetData*>(
      &::tradingpb::_PNLAssetData_default_instance_);
}
inline const ::tradingpb::PNLAssetData& PNLData::total() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLData.total)
  return _internal_total();
}
inline ::tradingpb::PNLAssetData* PNLData::release_total() {
  // @@protoc_insertion_point(field_release:tradingpb.PNLData.total)
  
  ::tradingpb::PNLAssetData* temp = total_;
  total_ = nullptr;
  return temp;
}
inline ::tradingpb::PNLAssetData* PNLData::_internal_mutable_total() {
  
  if (total_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::PNLAssetData>(GetArenaNoVirtual());
    total_ = p;
  }
  return total_;
}
inline ::tradingpb::PNLAssetData* PNLData::mutable_total() {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLData.total)
  return _internal_mutable_total();
}
inline void PNLData::set_allocated_total(::tradingpb::PNLAssetData* total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete total_;
  }
  if (total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total, submessage_arena);
    }
    
  } else {
    
  }
  total_ = total;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.PNLData.total)
}

// repeated .tradingpb.PNLAssetData assets = 3 [deprecated = true];
inline int PNLData::_internal_assets_size() const {
  return assets_.size();
}
inline int PNLData::assets_size() const {
  return _internal_assets_size();
}
inline void PNLData::clear_assets() {
  assets_.Clear();
}
inline ::tradingpb::PNLAssetData* PNLData::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLData.assets)
  return assets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLAssetData >*
PNLData::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.PNLData.assets)
  return &assets_;
}
inline const ::tradingpb::PNLAssetData& PNLData::_internal_assets(int index) const {
  return assets_.Get(index);
}
inline const ::tradingpb::PNLAssetData& PNLData::assets(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLData.assets)
  return _internal_assets(index);
}
inline ::tradingpb::PNLAssetData* PNLData::_internal_add_assets() {
  return assets_.Add();
}
inline ::tradingpb::PNLAssetData* PNLData::add_assets() {
  // @@protoc_insertion_point(field_add:tradingpb.PNLData.assets)
  return _internal_add_assets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLAssetData >&
PNLData::assets() const {
  // @@protoc_insertion_point(field_list:tradingpb.PNLData.assets)
  return assets_;
}

// string title = 4;
inline void PNLData::clear_title() {
  title_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PNLData::title() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLData.title)
  return _internal_title();
}
inline void PNLData::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLData.title)
}
inline std::string* PNLData::mutable_title() {
  // @@protoc_insertion_point(field_mutable:tradingpb.PNLData.title)
  return _internal_mutable_title();
}
inline const std::string& PNLData::_internal_title() const {
  return title_.GetNoArena();
}
inline void PNLData::_internal_set_title(const std::string& value) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PNLData::set_title(std::string&& value) {
  
  title_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.PNLData.title)
}
inline void PNLData::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.PNLData.title)
}
inline void PNLData::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.PNLData.title)
}
inline std::string* PNLData::_internal_mutable_title() {
  
  return title_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PNLData::release_title() {
  // @@protoc_insertion_point(field_release:tradingpb.PNLData.title)
  
  return title_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PNLData::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.PNLData.title)
}

// int64 lastts = 5 [deprecated = true];
inline void PNLData::clear_lastts() {
  lastts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLData::_internal_lastts() const {
  return lastts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PNLData::lastts() const {
  // @@protoc_insertion_point(field_get:tradingpb.PNLData.lastts)
  return _internal_lastts();
}
inline void PNLData::_internal_set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  lastts_ = value;
}
inline void PNLData::set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_lastts(value);
  // @@protoc_insertion_point(field_set:tradingpb.PNLData.lastts)
}

// -------------------------------------------------------------------

// SimTradingParams

// repeated .tradingpb.Asset assets = 1;
inline int SimTradingParams::_internal_assets_size() const {
  return assets_.size();
}
inline int SimTradingParams::assets_size() const {
  return _internal_assets_size();
}
inline void SimTradingParams::clear_assets() {
  assets_.Clear();
}
inline ::tradingpb::Asset* SimTradingParams::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingParams.assets)
  return assets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >*
SimTradingParams::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.SimTradingParams.assets)
  return &assets_;
}
inline const ::tradingpb::Asset& SimTradingParams::_internal_assets(int index) const {
  return assets_.Get(index);
}
inline const ::tradingpb::Asset& SimTradingParams::assets(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.assets)
  return _internal_assets(index);
}
inline ::tradingpb::Asset* SimTradingParams::_internal_add_assets() {
  return assets_.Add();
}
inline ::tradingpb::Asset* SimTradingParams::add_assets() {
  // @@protoc_insertion_point(field_add:tradingpb.SimTradingParams.assets)
  return _internal_add_assets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >&
SimTradingParams::assets() const {
  // @@protoc_insertion_point(field_list:tradingpb.SimTradingParams.assets)
  return assets_;
}

// repeated .tradingpb.Asset baselines = 2 [deprecated = true];
inline int SimTradingParams::_internal_baselines_size() const {
  return baselines_.size();
}
inline int SimTradingParams::baselines_size() const {
  return _internal_baselines_size();
}
inline void SimTradingParams::clear_baselines() {
  baselines_.Clear();
}
inline ::tradingpb::Asset* SimTradingParams::mutable_baselines(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingParams.baselines)
  return baselines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >*
SimTradingParams::mutable_baselines() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.SimTradingParams.baselines)
  return &baselines_;
}
inline const ::tradingpb::Asset& SimTradingParams::_internal_baselines(int index) const {
  return baselines_.Get(index);
}
inline const ::tradingpb::Asset& SimTradingParams::baselines(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.baselines)
  return _internal_baselines(index);
}
inline ::tradingpb::Asset* SimTradingParams::_internal_add_baselines() {
  return baselines_.Add();
}
inline ::tradingpb::Asset* SimTradingParams::add_baselines() {
  // @@protoc_insertion_point(field_add:tradingpb.SimTradingParams.baselines)
  return _internal_add_baselines();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Asset >&
SimTradingParams::baselines() const {
  // @@protoc_insertion_point(field_list:tradingpb.SimTradingParams.baselines)
  return baselines_;
}

// int64 startTs = 3;
inline void SimTradingParams::clear_startts() {
  startts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimTradingParams::_internal_startts() const {
  return startts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimTradingParams::startts() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.startTs)
  return _internal_startts();
}
inline void SimTradingParams::_internal_set_startts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  startts_ = value;
}
inline void SimTradingParams::set_startts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_startts(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.startTs)
}

// int64 endTs = 4;
inline void SimTradingParams::clear_endts() {
  endts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimTradingParams::_internal_endts() const {
  return endts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimTradingParams::endts() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.endTs)
  return _internal_endts();
}
inline void SimTradingParams::_internal_set_endts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  endts_ = value;
}
inline void SimTradingParams::set_endts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_endts(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.endTs)
}

// repeated .tradingpb.Strategy strategies = 5;
inline int SimTradingParams::_internal_strategies_size() const {
  return strategies_.size();
}
inline int SimTradingParams::strategies_size() const {
  return _internal_strategies_size();
}
inline void SimTradingParams::clear_strategies() {
  strategies_.Clear();
}
inline ::tradingpb::Strategy* SimTradingParams::mutable_strategies(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingParams.strategies)
  return strategies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Strategy >*
SimTradingParams::mutable_strategies() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.SimTradingParams.strategies)
  return &strategies_;
}
inline const ::tradingpb::Strategy& SimTradingParams::_internal_strategies(int index) const {
  return strategies_.Get(index);
}
inline const ::tradingpb::Strategy& SimTradingParams::strategies(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.strategies)
  return _internal_strategies(index);
}
inline ::tradingpb::Strategy* SimTradingParams::_internal_add_strategies() {
  return strategies_.Add();
}
inline ::tradingpb::Strategy* SimTradingParams::add_strategies() {
  // @@protoc_insertion_point(field_add:tradingpb.SimTradingParams.strategies)
  return _internal_add_strategies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::Strategy >&
SimTradingParams::strategies() const {
  // @@protoc_insertion_point(field_list:tradingpb.SimTradingParams.strategies)
  return strategies_;
}

// .tradingpb.Wallet wallet = 6;
inline bool SimTradingParams::_internal_has_wallet() const {
  return this != internal_default_instance() && wallet_ != nullptr;
}
inline bool SimTradingParams::has_wallet() const {
  return _internal_has_wallet();
}
inline void SimTradingParams::clear_wallet() {
  if (GetArenaNoVirtual() == nullptr && wallet_ != nullptr) {
    delete wallet_;
  }
  wallet_ = nullptr;
}
inline const ::tradingpb::Wallet& SimTradingParams::_internal_wallet() const {
  const ::tradingpb::Wallet* p = wallet_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::Wallet*>(
      &::tradingpb::_Wallet_default_instance_);
}
inline const ::tradingpb::Wallet& SimTradingParams::wallet() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.wallet)
  return _internal_wallet();
}
inline ::tradingpb::Wallet* SimTradingParams::release_wallet() {
  // @@protoc_insertion_point(field_release:tradingpb.SimTradingParams.wallet)
  
  ::tradingpb::Wallet* temp = wallet_;
  wallet_ = nullptr;
  return temp;
}
inline ::tradingpb::Wallet* SimTradingParams::_internal_mutable_wallet() {
  
  if (wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::Wallet>(GetArenaNoVirtual());
    wallet_ = p;
  }
  return wallet_;
}
inline ::tradingpb::Wallet* SimTradingParams::mutable_wallet() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingParams.wallet)
  return _internal_mutable_wallet();
}
inline void SimTradingParams::set_allocated_wallet(::tradingpb::Wallet* wallet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wallet_;
  }
  if (wallet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wallet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wallet, submessage_arena);
    }
    
  } else {
    
  }
  wallet_ = wallet;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SimTradingParams.wallet)
}

// string title = 7;
inline void SimTradingParams::clear_title() {
  title_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimTradingParams::title() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.title)
  return _internal_title();
}
inline void SimTradingParams::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.title)
}
inline std::string* SimTradingParams::mutable_title() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingParams.title)
  return _internal_mutable_title();
}
inline const std::string& SimTradingParams::_internal_title() const {
  return title_.GetNoArena();
}
inline void SimTradingParams::_internal_set_title(const std::string& value) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimTradingParams::set_title(std::string&& value) {
  
  title_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SimTradingParams.title)
}
inline void SimTradingParams::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SimTradingParams.title)
}
inline void SimTradingParams::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SimTradingParams.title)
}
inline std::string* SimTradingParams::_internal_mutable_title() {
  
  return title_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimTradingParams::release_title() {
  // @@protoc_insertion_point(field_release:tradingpb.SimTradingParams.title)
  
  return title_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimTradingParams::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SimTradingParams.title)
}

// int32 mainAssetIndex = 8;
inline void SimTradingParams::clear_mainassetindex() {
  mainassetindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimTradingParams::_internal_mainassetindex() const {
  return mainassetindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimTradingParams::mainassetindex() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.mainAssetIndex)
  return _internal_mainassetindex();
}
inline void SimTradingParams::_internal_set_mainassetindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mainassetindex_ = value;
}
inline void SimTradingParams::set_mainassetindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mainassetindex(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.mainAssetIndex)
}

// repeated string indicators = 9;
inline int SimTradingParams::_internal_indicators_size() const {
  return indicators_.size();
}
inline int SimTradingParams::indicators_size() const {
  return _internal_indicators_size();
}
inline void SimTradingParams::clear_indicators() {
  indicators_.Clear();
}
inline std::string* SimTradingParams::add_indicators() {
  // @@protoc_insertion_point(field_add_mutable:tradingpb.SimTradingParams.indicators)
  return _internal_add_indicators();
}
inline const std::string& SimTradingParams::_internal_indicators(int index) const {
  return indicators_.Get(index);
}
inline const std::string& SimTradingParams::indicators(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.indicators)
  return _internal_indicators(index);
}
inline std::string* SimTradingParams::mutable_indicators(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingParams.indicators)
  return indicators_.Mutable(index);
}
inline void SimTradingParams::set_indicators(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.indicators)
  indicators_.Mutable(index)->assign(value);
}
inline void SimTradingParams::set_indicators(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.indicators)
  indicators_.Mutable(index)->assign(std::move(value));
}
inline void SimTradingParams::set_indicators(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  indicators_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tradingpb.SimTradingParams.indicators)
}
inline void SimTradingParams::set_indicators(int index, const char* value, size_t size) {
  indicators_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SimTradingParams.indicators)
}
inline std::string* SimTradingParams::_internal_add_indicators() {
  return indicators_.Add();
}
inline void SimTradingParams::add_indicators(const std::string& value) {
  indicators_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tradingpb.SimTradingParams.indicators)
}
inline void SimTradingParams::add_indicators(std::string&& value) {
  indicators_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tradingpb.SimTradingParams.indicators)
}
inline void SimTradingParams::add_indicators(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  indicators_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tradingpb.SimTradingParams.indicators)
}
inline void SimTradingParams::add_indicators(const char* value, size_t size) {
  indicators_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tradingpb.SimTradingParams.indicators)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SimTradingParams::indicators() const {
  // @@protoc_insertion_point(field_list:tradingpb.SimTradingParams.indicators)
  return indicators_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SimTradingParams::mutable_indicators() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.SimTradingParams.indicators)
  return &indicators_;
}

// int32 offset = 10;
inline void SimTradingParams::clear_offset() {
  offset_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimTradingParams::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimTradingParams::offset() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingParams.offset)
  return _internal_offset();
}
inline void SimTradingParams::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  offset_ = value;
}
inline void SimTradingParams::set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingParams.offset)
}

// -------------------------------------------------------------------

// TradingNodeInfo

// int32 maxTasks = 1;
inline void TradingNodeInfo::clear_maxtasks() {
  maxtasks_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TradingNodeInfo::_internal_maxtasks() const {
  return maxtasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TradingNodeInfo::maxtasks() const {
  // @@protoc_insertion_point(field_get:tradingpb.TradingNodeInfo.maxTasks)
  return _internal_maxtasks();
}
inline void TradingNodeInfo::_internal_set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxtasks_ = value;
}
inline void TradingNodeInfo::set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxtasks(value);
  // @@protoc_insertion_point(field_set:tradingpb.TradingNodeInfo.maxTasks)
}

// int32 curTasks = 2;
inline void TradingNodeInfo::clear_curtasks() {
  curtasks_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TradingNodeInfo::_internal_curtasks() const {
  return curtasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TradingNodeInfo::curtasks() const {
  // @@protoc_insertion_point(field_get:tradingpb.TradingNodeInfo.curTasks)
  return _internal_curtasks();
}
inline void TradingNodeInfo::_internal_set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curtasks_ = value;
}
inline void TradingNodeInfo::set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curtasks(value);
  // @@protoc_insertion_point(field_set:tradingpb.TradingNodeInfo.curTasks)
}

// -------------------------------------------------------------------

// SimTradingCacheNode

// .tradingpb.SimTradingParams params = 1;
inline bool SimTradingCacheNode::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool SimTradingCacheNode::has_params() const {
  return _internal_has_params();
}
inline void SimTradingCacheNode::clear_params() {
  if (GetArenaNoVirtual() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::tradingpb::SimTradingParams& SimTradingCacheNode::_internal_params() const {
  const ::tradingpb::SimTradingParams* p = params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::SimTradingParams*>(
      &::tradingpb::_SimTradingParams_default_instance_);
}
inline const ::tradingpb::SimTradingParams& SimTradingCacheNode::params() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingCacheNode.params)
  return _internal_params();
}
inline ::tradingpb::SimTradingParams* SimTradingCacheNode::release_params() {
  // @@protoc_insertion_point(field_release:tradingpb.SimTradingCacheNode.params)
  
  ::tradingpb::SimTradingParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::tradingpb::SimTradingParams* SimTradingCacheNode::_internal_mutable_params() {
  
  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::SimTradingParams>(GetArenaNoVirtual());
    params_ = p;
  }
  return params_;
}
inline ::tradingpb::SimTradingParams* SimTradingCacheNode::mutable_params() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingCacheNode.params)
  return _internal_mutable_params();
}
inline void SimTradingCacheNode::set_allocated_params(::tradingpb::SimTradingParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SimTradingCacheNode.params)
}

// string key = 2;
inline void SimTradingCacheNode::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimTradingCacheNode::key() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingCacheNode.key)
  return _internal_key();
}
inline void SimTradingCacheNode::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingCacheNode.key)
}
inline std::string* SimTradingCacheNode::mutable_key() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingCacheNode.key)
  return _internal_mutable_key();
}
inline const std::string& SimTradingCacheNode::_internal_key() const {
  return key_.GetNoArena();
}
inline void SimTradingCacheNode::_internal_set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimTradingCacheNode::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SimTradingCacheNode.key)
}
inline void SimTradingCacheNode::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SimTradingCacheNode.key)
}
inline void SimTradingCacheNode::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SimTradingCacheNode.key)
}
inline std::string* SimTradingCacheNode::_internal_mutable_key() {
  
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimTradingCacheNode::release_key() {
  // @@protoc_insertion_point(field_release:tradingpb.SimTradingCacheNode.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimTradingCacheNode::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SimTradingCacheNode.key)
}

// int64 lastTs = 3;
inline void SimTradingCacheNode::clear_lastts() {
  lastts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimTradingCacheNode::_internal_lastts() const {
  return lastts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimTradingCacheNode::lastts() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingCacheNode.lastTs)
  return _internal_lastts();
}
inline void SimTradingCacheNode::_internal_set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  lastts_ = value;
}
inline void SimTradingCacheNode::set_lastts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_lastts(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingCacheNode.lastTs)
}

// string hash = 4 [deprecated = true];
inline void SimTradingCacheNode::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimTradingCacheNode::hash() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingCacheNode.hash)
  return _internal_hash();
}
inline void SimTradingCacheNode::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingCacheNode.hash)
}
inline std::string* SimTradingCacheNode::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingCacheNode.hash)
  return _internal_mutable_hash();
}
inline const std::string& SimTradingCacheNode::_internal_hash() const {
  return hash_.GetNoArena();
}
inline void SimTradingCacheNode::_internal_set_hash(const std::string& value) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimTradingCacheNode::set_hash(std::string&& value) {
  
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SimTradingCacheNode.hash)
}
inline void SimTradingCacheNode::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SimTradingCacheNode.hash)
}
inline void SimTradingCacheNode::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SimTradingCacheNode.hash)
}
inline std::string* SimTradingCacheNode::_internal_mutable_hash() {
  
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimTradingCacheNode::release_hash() {
  // @@protoc_insertion_point(field_release:tradingpb.SimTradingCacheNode.hash)
  
  return hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimTradingCacheNode::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SimTradingCacheNode.hash)
}

// bytes buf = 5;
inline void SimTradingCacheNode::clear_buf() {
  buf_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimTradingCacheNode::buf() const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingCacheNode.buf)
  return _internal_buf();
}
inline void SimTradingCacheNode::set_buf(const std::string& value) {
  _internal_set_buf(value);
  // @@protoc_insertion_point(field_set:tradingpb.SimTradingCacheNode.buf)
}
inline std::string* SimTradingCacheNode::mutable_buf() {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingCacheNode.buf)
  return _internal_mutable_buf();
}
inline const std::string& SimTradingCacheNode::_internal_buf() const {
  return buf_.GetNoArena();
}
inline void SimTradingCacheNode::_internal_set_buf(const std::string& value) {
  
  buf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimTradingCacheNode::set_buf(std::string&& value) {
  
  buf_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tradingpb.SimTradingCacheNode.buf)
}
inline void SimTradingCacheNode::set_buf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  buf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tradingpb.SimTradingCacheNode.buf)
}
inline void SimTradingCacheNode::set_buf(const void* value, size_t size) {
  
  buf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tradingpb.SimTradingCacheNode.buf)
}
inline std::string* SimTradingCacheNode::_internal_mutable_buf() {
  
  return buf_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimTradingCacheNode::release_buf() {
  // @@protoc_insertion_point(field_release:tradingpb.SimTradingCacheNode.buf)
  
  return buf_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimTradingCacheNode::set_allocated_buf(std::string* buf) {
  if (buf != nullptr) {
    
  } else {
    
  }
  buf_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buf);
  // @@protoc_insertion_point(field_set_allocated:tradingpb.SimTradingCacheNode.buf)
}

// -------------------------------------------------------------------

// SimTradingCache

// repeated .tradingpb.SimTradingCacheNode nodes = 1;
inline int SimTradingCache::_internal_nodes_size() const {
  return nodes_.size();
}
inline int SimTradingCache::nodes_size() const {
  return _internal_nodes_size();
}
inline void SimTradingCache::clear_nodes() {
  nodes_.Clear();
}
inline ::tradingpb::SimTradingCacheNode* SimTradingCache::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.SimTradingCache.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::SimTradingCacheNode >*
SimTradingCache::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.SimTradingCache.nodes)
  return &nodes_;
}
inline const ::tradingpb::SimTradingCacheNode& SimTradingCache::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::tradingpb::SimTradingCacheNode& SimTradingCache::nodes(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.SimTradingCache.nodes)
  return _internal_nodes(index);
}
inline ::tradingpb::SimTradingCacheNode* SimTradingCache::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::tradingpb::SimTradingCacheNode* SimTradingCache::add_nodes() {
  // @@protoc_insertion_point(field_add:tradingpb.SimTradingCache.nodes)
  return _internal_add_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::SimTradingCacheNode >&
SimTradingCache::nodes() const {
  // @@protoc_insertion_point(field_list:tradingpb.SimTradingCache.nodes)
  return nodes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tradingpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tradingpb::CtrlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tradingpb::CtrlType>() {
  return ::tradingpb::CtrlType_descriptor();
}
template <> struct is_proto_enum< ::tradingpb::IndicatorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tradingpb::IndicatorType>() {
  return ::tradingpb::IndicatorType_descriptor();
}
template <> struct is_proto_enum< ::tradingpb::AIPTimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tradingpb::AIPTimeType>() {
  return ::tradingpb::AIPTimeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_trading2_2eproto
