// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tradingnode2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tradingnode2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tradingnode2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "trading2.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tradingnode2_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tradingnode2_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tradingnode2_2eproto;
namespace tradingpb {
class ReplyCalcPNL;
class ReplyCalcPNLDefaultTypeInternal;
extern ReplyCalcPNLDefaultTypeInternal _ReplyCalcPNL_default_instance_;
class ReplyServerInfo;
class ReplyServerInfoDefaultTypeInternal;
extern ReplyServerInfoDefaultTypeInternal _ReplyServerInfo_default_instance_;
class RequestCalcPNL;
class RequestCalcPNLDefaultTypeInternal;
extern RequestCalcPNLDefaultTypeInternal _RequestCalcPNL_default_instance_;
class RequestServerInfo;
class RequestServerInfoDefaultTypeInternal;
extern RequestServerInfoDefaultTypeInternal _RequestServerInfo_default_instance_;
}  // namespace tradingpb
PROTOBUF_NAMESPACE_OPEN
template<> ::tradingpb::ReplyCalcPNL* Arena::CreateMaybeMessage<::tradingpb::ReplyCalcPNL>(Arena*);
template<> ::tradingpb::ReplyServerInfo* Arena::CreateMaybeMessage<::tradingpb::ReplyServerInfo>(Arena*);
template<> ::tradingpb::RequestCalcPNL* Arena::CreateMaybeMessage<::tradingpb::RequestCalcPNL>(Arena*);
template<> ::tradingpb::RequestServerInfo* Arena::CreateMaybeMessage<::tradingpb::RequestServerInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tradingpb {

// ===================================================================

class RequestServerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.RequestServerInfo) */ {
 public:
  RequestServerInfo();
  virtual ~RequestServerInfo();

  RequestServerInfo(const RequestServerInfo& from);
  RequestServerInfo(RequestServerInfo&& from) noexcept
    : RequestServerInfo() {
    *this = ::std::move(from);
  }

  inline RequestServerInfo& operator=(const RequestServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestServerInfo& operator=(RequestServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestServerInfo* internal_default_instance() {
    return reinterpret_cast<const RequestServerInfo*>(
               &_RequestServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestServerInfo& a, RequestServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestServerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestServerInfo* New() const final {
    return CreateMaybeMessage<RequestServerInfo>(nullptr);
  }

  RequestServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestServerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestServerInfo& from);
  void MergeFrom(const RequestServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.RequestServerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tradingnode2_2eproto);
    return ::descriptor_table_tradingnode2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicRequestFieldNumber = 1,
  };
  // .tradingpb.BasicRequestData basicRequest = 1;
  bool has_basicrequest() const;
  private:
  bool _internal_has_basicrequest() const;
  public:
  void clear_basicrequest();
  const ::tradingpb::BasicRequestData& basicrequest() const;
  ::tradingpb::BasicRequestData* release_basicrequest();
  ::tradingpb::BasicRequestData* mutable_basicrequest();
  void set_allocated_basicrequest(::tradingpb::BasicRequestData* basicrequest);
  private:
  const ::tradingpb::BasicRequestData& _internal_basicrequest() const;
  ::tradingpb::BasicRequestData* _internal_mutable_basicrequest();
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.RequestServerInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tradingpb::BasicRequestData* basicrequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tradingnode2_2eproto;
};
// -------------------------------------------------------------------

class ReplyServerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.ReplyServerInfo) */ {
 public:
  ReplyServerInfo();
  virtual ~ReplyServerInfo();

  ReplyServerInfo(const ReplyServerInfo& from);
  ReplyServerInfo(ReplyServerInfo&& from) noexcept
    : ReplyServerInfo() {
    *this = ::std::move(from);
  }

  inline ReplyServerInfo& operator=(const ReplyServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyServerInfo& operator=(ReplyServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplyServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyServerInfo* internal_default_instance() {
    return reinterpret_cast<const ReplyServerInfo*>(
               &_ReplyServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReplyServerInfo& a, ReplyServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyServerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplyServerInfo* New() const final {
    return CreateMaybeMessage<ReplyServerInfo>(nullptr);
  }

  ReplyServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplyServerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplyServerInfo& from);
  void MergeFrom(const ReplyServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.ReplyServerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tradingnode2_2eproto);
    return ::descriptor_table_tradingnode2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxTasksFieldNumber = 1,
    kCurTasksFieldNumber = 2,
  };
  // int32 maxTasks = 1;
  void clear_maxtasks();
  ::PROTOBUF_NAMESPACE_ID::int32 maxtasks() const;
  void set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxtasks() const;
  void _internal_set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curTasks = 2;
  void clear_curtasks();
  ::PROTOBUF_NAMESPACE_ID::int32 curtasks() const;
  void set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curtasks() const;
  void _internal_set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.ReplyServerInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxtasks_;
  ::PROTOBUF_NAMESPACE_ID::int32 curtasks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tradingnode2_2eproto;
};
// -------------------------------------------------------------------

class RequestCalcPNL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.RequestCalcPNL) */ {
 public:
  RequestCalcPNL();
  virtual ~RequestCalcPNL();

  RequestCalcPNL(const RequestCalcPNL& from);
  RequestCalcPNL(RequestCalcPNL&& from) noexcept
    : RequestCalcPNL() {
    *this = ::std::move(from);
  }

  inline RequestCalcPNL& operator=(const RequestCalcPNL& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCalcPNL& operator=(RequestCalcPNL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestCalcPNL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCalcPNL* internal_default_instance() {
    return reinterpret_cast<const RequestCalcPNL*>(
               &_RequestCalcPNL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestCalcPNL& a, RequestCalcPNL& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCalcPNL* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestCalcPNL* New() const final {
    return CreateMaybeMessage<RequestCalcPNL>(nullptr);
  }

  RequestCalcPNL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestCalcPNL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestCalcPNL& from);
  void MergeFrom(const RequestCalcPNL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCalcPNL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.RequestCalcPNL";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tradingnode2_2eproto);
    return ::descriptor_table_tradingnode2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicRequestFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // .tradingpb.BasicRequestData basicRequest = 1;
  bool has_basicrequest() const;
  private:
  bool _internal_has_basicrequest() const;
  public:
  void clear_basicrequest();
  const ::tradingpb::BasicRequestData& basicrequest() const;
  ::tradingpb::BasicRequestData* release_basicrequest();
  ::tradingpb::BasicRequestData* mutable_basicrequest();
  void set_allocated_basicrequest(::tradingpb::BasicRequestData* basicrequest);
  private:
  const ::tradingpb::BasicRequestData& _internal_basicrequest() const;
  ::tradingpb::BasicRequestData* _internal_mutable_basicrequest();
  public:

  // .tradingpb.SimTradingParams params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::tradingpb::SimTradingParams& params() const;
  ::tradingpb::SimTradingParams* release_params();
  ::tradingpb::SimTradingParams* mutable_params();
  void set_allocated_params(::tradingpb::SimTradingParams* params);
  private:
  const ::tradingpb::SimTradingParams& _internal_params() const;
  ::tradingpb::SimTradingParams* _internal_mutable_params();
  public:

  // @@protoc_insertion_point(class_scope:tradingpb.RequestCalcPNL)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tradingpb::BasicRequestData* basicrequest_;
  ::tradingpb::SimTradingParams* params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tradingnode2_2eproto;
};
// -------------------------------------------------------------------

class ReplyCalcPNL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tradingpb.ReplyCalcPNL) */ {
 public:
  ReplyCalcPNL();
  virtual ~ReplyCalcPNL();

  ReplyCalcPNL(const ReplyCalcPNL& from);
  ReplyCalcPNL(ReplyCalcPNL&& from) noexcept
    : ReplyCalcPNL() {
    *this = ::std::move(from);
  }

  inline ReplyCalcPNL& operator=(const ReplyCalcPNL& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyCalcPNL& operator=(ReplyCalcPNL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplyCalcPNL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyCalcPNL* internal_default_instance() {
    return reinterpret_cast<const ReplyCalcPNL*>(
               &_ReplyCalcPNL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReplyCalcPNL& a, ReplyCalcPNL& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyCalcPNL* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplyCalcPNL* New() const final {
    return CreateMaybeMessage<ReplyCalcPNL>(nullptr);
  }

  ReplyCalcPNL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplyCalcPNL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplyCalcPNL& from);
  void MergeFrom(const ReplyCalcPNL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyCalcPNL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tradingpb.ReplyCalcPNL";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tradingnode2_2eproto);
    return ::descriptor_table_tradingnode2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPnlFieldNumber = 1,
  };
  // repeated .tradingpb.PNLData pnl = 1;
  int pnl_size() const;
  private:
  int _internal_pnl_size() const;
  public:
  void clear_pnl();
  ::tradingpb::PNLData* mutable_pnl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLData >*
      mutable_pnl();
  private:
  const ::tradingpb::PNLData& _internal_pnl(int index) const;
  ::tradingpb::PNLData* _internal_add_pnl();
  public:
  const ::tradingpb::PNLData& pnl(int index) const;
  ::tradingpb::PNLData* add_pnl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLData >&
      pnl() const;

  // @@protoc_insertion_point(class_scope:tradingpb.ReplyCalcPNL)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLData > pnl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tradingnode2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestServerInfo

// .tradingpb.BasicRequestData basicRequest = 1;
inline bool RequestServerInfo::_internal_has_basicrequest() const {
  return this != internal_default_instance() && basicrequest_ != nullptr;
}
inline bool RequestServerInfo::has_basicrequest() const {
  return _internal_has_basicrequest();
}
inline const ::tradingpb::BasicRequestData& RequestServerInfo::_internal_basicrequest() const {
  const ::tradingpb::BasicRequestData* p = basicrequest_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::BasicRequestData*>(
      &::tradingpb::_BasicRequestData_default_instance_);
}
inline const ::tradingpb::BasicRequestData& RequestServerInfo::basicrequest() const {
  // @@protoc_insertion_point(field_get:tradingpb.RequestServerInfo.basicRequest)
  return _internal_basicrequest();
}
inline ::tradingpb::BasicRequestData* RequestServerInfo::release_basicrequest() {
  // @@protoc_insertion_point(field_release:tradingpb.RequestServerInfo.basicRequest)
  
  ::tradingpb::BasicRequestData* temp = basicrequest_;
  basicrequest_ = nullptr;
  return temp;
}
inline ::tradingpb::BasicRequestData* RequestServerInfo::_internal_mutable_basicrequest() {
  
  if (basicrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::BasicRequestData>(GetArenaNoVirtual());
    basicrequest_ = p;
  }
  return basicrequest_;
}
inline ::tradingpb::BasicRequestData* RequestServerInfo::mutable_basicrequest() {
  // @@protoc_insertion_point(field_mutable:tradingpb.RequestServerInfo.basicRequest)
  return _internal_mutable_basicrequest();
}
inline void RequestServerInfo::set_allocated_basicrequest(::tradingpb::BasicRequestData* basicrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(basicrequest_);
  }
  if (basicrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      basicrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basicrequest, submessage_arena);
    }
    
  } else {
    
  }
  basicrequest_ = basicrequest;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.RequestServerInfo.basicRequest)
}

// -------------------------------------------------------------------

// ReplyServerInfo

// int32 maxTasks = 1;
inline void ReplyServerInfo::clear_maxtasks() {
  maxtasks_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReplyServerInfo::_internal_maxtasks() const {
  return maxtasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReplyServerInfo::maxtasks() const {
  // @@protoc_insertion_point(field_get:tradingpb.ReplyServerInfo.maxTasks)
  return _internal_maxtasks();
}
inline void ReplyServerInfo::_internal_set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxtasks_ = value;
}
inline void ReplyServerInfo::set_maxtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxtasks(value);
  // @@protoc_insertion_point(field_set:tradingpb.ReplyServerInfo.maxTasks)
}

// int32 curTasks = 2;
inline void ReplyServerInfo::clear_curtasks() {
  curtasks_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReplyServerInfo::_internal_curtasks() const {
  return curtasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReplyServerInfo::curtasks() const {
  // @@protoc_insertion_point(field_get:tradingpb.ReplyServerInfo.curTasks)
  return _internal_curtasks();
}
inline void ReplyServerInfo::_internal_set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curtasks_ = value;
}
inline void ReplyServerInfo::set_curtasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curtasks(value);
  // @@protoc_insertion_point(field_set:tradingpb.ReplyServerInfo.curTasks)
}

// -------------------------------------------------------------------

// RequestCalcPNL

// .tradingpb.BasicRequestData basicRequest = 1;
inline bool RequestCalcPNL::_internal_has_basicrequest() const {
  return this != internal_default_instance() && basicrequest_ != nullptr;
}
inline bool RequestCalcPNL::has_basicrequest() const {
  return _internal_has_basicrequest();
}
inline const ::tradingpb::BasicRequestData& RequestCalcPNL::_internal_basicrequest() const {
  const ::tradingpb::BasicRequestData* p = basicrequest_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::BasicRequestData*>(
      &::tradingpb::_BasicRequestData_default_instance_);
}
inline const ::tradingpb::BasicRequestData& RequestCalcPNL::basicrequest() const {
  // @@protoc_insertion_point(field_get:tradingpb.RequestCalcPNL.basicRequest)
  return _internal_basicrequest();
}
inline ::tradingpb::BasicRequestData* RequestCalcPNL::release_basicrequest() {
  // @@protoc_insertion_point(field_release:tradingpb.RequestCalcPNL.basicRequest)
  
  ::tradingpb::BasicRequestData* temp = basicrequest_;
  basicrequest_ = nullptr;
  return temp;
}
inline ::tradingpb::BasicRequestData* RequestCalcPNL::_internal_mutable_basicrequest() {
  
  if (basicrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::BasicRequestData>(GetArenaNoVirtual());
    basicrequest_ = p;
  }
  return basicrequest_;
}
inline ::tradingpb::BasicRequestData* RequestCalcPNL::mutable_basicrequest() {
  // @@protoc_insertion_point(field_mutable:tradingpb.RequestCalcPNL.basicRequest)
  return _internal_mutable_basicrequest();
}
inline void RequestCalcPNL::set_allocated_basicrequest(::tradingpb::BasicRequestData* basicrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(basicrequest_);
  }
  if (basicrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      basicrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basicrequest, submessage_arena);
    }
    
  } else {
    
  }
  basicrequest_ = basicrequest;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.RequestCalcPNL.basicRequest)
}

// .tradingpb.SimTradingParams params = 2;
inline bool RequestCalcPNL::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool RequestCalcPNL::has_params() const {
  return _internal_has_params();
}
inline const ::tradingpb::SimTradingParams& RequestCalcPNL::_internal_params() const {
  const ::tradingpb::SimTradingParams* p = params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tradingpb::SimTradingParams*>(
      &::tradingpb::_SimTradingParams_default_instance_);
}
inline const ::tradingpb::SimTradingParams& RequestCalcPNL::params() const {
  // @@protoc_insertion_point(field_get:tradingpb.RequestCalcPNL.params)
  return _internal_params();
}
inline ::tradingpb::SimTradingParams* RequestCalcPNL::release_params() {
  // @@protoc_insertion_point(field_release:tradingpb.RequestCalcPNL.params)
  
  ::tradingpb::SimTradingParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::tradingpb::SimTradingParams* RequestCalcPNL::_internal_mutable_params() {
  
  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::tradingpb::SimTradingParams>(GetArenaNoVirtual());
    params_ = p;
  }
  return params_;
}
inline ::tradingpb::SimTradingParams* RequestCalcPNL::mutable_params() {
  // @@protoc_insertion_point(field_mutable:tradingpb.RequestCalcPNL.params)
  return _internal_mutable_params();
}
inline void RequestCalcPNL::set_allocated_params(::tradingpb::SimTradingParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:tradingpb.RequestCalcPNL.params)
}

// -------------------------------------------------------------------

// ReplyCalcPNL

// repeated .tradingpb.PNLData pnl = 1;
inline int ReplyCalcPNL::_internal_pnl_size() const {
  return pnl_.size();
}
inline int ReplyCalcPNL::pnl_size() const {
  return _internal_pnl_size();
}
inline ::tradingpb::PNLData* ReplyCalcPNL::mutable_pnl(int index) {
  // @@protoc_insertion_point(field_mutable:tradingpb.ReplyCalcPNL.pnl)
  return pnl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLData >*
ReplyCalcPNL::mutable_pnl() {
  // @@protoc_insertion_point(field_mutable_list:tradingpb.ReplyCalcPNL.pnl)
  return &pnl_;
}
inline const ::tradingpb::PNLData& ReplyCalcPNL::_internal_pnl(int index) const {
  return pnl_.Get(index);
}
inline const ::tradingpb::PNLData& ReplyCalcPNL::pnl(int index) const {
  // @@protoc_insertion_point(field_get:tradingpb.ReplyCalcPNL.pnl)
  return _internal_pnl(index);
}
inline ::tradingpb::PNLData* ReplyCalcPNL::_internal_add_pnl() {
  return pnl_.Add();
}
inline ::tradingpb::PNLData* ReplyCalcPNL::add_pnl() {
  // @@protoc_insertion_point(field_add:tradingpb.ReplyCalcPNL.pnl)
  return _internal_add_pnl();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tradingpb::PNLData >&
ReplyCalcPNL::pnl() const {
  // @@protoc_insertion_point(field_list:tradingpb.ReplyCalcPNL.pnl)
  return pnl_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tradingpb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tradingnode2_2eproto
